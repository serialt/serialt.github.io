[{"categories":["Go 库文档"],"content":"gopsutil 库 参考链接：https://segmentfault.com/a/1190000022281174 ","date":"2023-11-11","objectID":"/posts/2023-11-11-gopsutil/:1:0","tags":["Go","gopsutil"],"title":"Go gopsutil","uri":"/posts/2023-11-11-gopsutil/"},{"categories":["Go 库文档"],"content":"简介 gopsutil是 Python 工具库psutil 的 Golang 移植版，可以帮助我们方便地获取各种系统和硬件信息。gopsutil为我们屏蔽了各个系统之间的差异，具有非常强悍的可移植性。有了gopsutil，我们不再需要针对不同的系统使用syscall调用对应的系统方法。更棒的是gopsutil的实现中没有任何cgo的代码，使得交叉编译成为可能。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-gopsutil/:1:1","tags":["Go","gopsutil"],"title":"Go gopsutil","uri":"/posts/2023-11-11-gopsutil/"},{"categories":["Go 库文档"],"content":"快速使用 安装 go get github.com/shirou/gopsutil 使用 package main import ( \"fmt\" \"github.com/shirou/gopsutil/mem\" ) func main() { v, _ := mem.VirtualMemory() fmt.Printf(\"Total: %v, Available: %v, UsedPercent:%f%%\\n\", v.Total, v.Available, v.UsedPercent) fmt.Println(v) } gopsutil将不同的功能划分到不同的子包中： cpu：CPU 相关； disk：磁盘相关； docker：docker 相关； host：主机相关； mem：内存相关； net：网络相关； process：进程相关； winservices：Windows 服务相关。 想要使用对应的功能，要导入对应的子包。例如，上面代码中，我们要获取内存信息，导入的是mem子包。mem.VirtualMemory()方法返回内存信息结构mem.VirtualMemoryStat，该结构有丰富的字段，我们最常使用的无外乎Total（总内存）、Available（可用内存）、Used（已使用内存）和UsedPercent（内存使用百分比）。mem.VirtualMemoryStat还实现了fmt.Stringer接口，以 JSON 格式返回内存信息。语句fmt.Println(v)会自动调用v.String()，将返回信息输出。程序输出： Total: 8526921728, Available: 3768975360, UsedPercent:55.000000% {\"total\":8526921728,\"available\":3768975360,\"used\":4757946368,\"usedPercent\":55,\"free\":0,\"active\":0,\"inactive\":0,\"wired\":0,\"laundry\":0,\"buffers\":0,\"cached\":0,\"writeback\":0,\"dirty\":0,\"writebacktmp\":0,\"shared\":0,\"slab\":0,\"sreclaimable\":0,\"sunreclaim\":0,\"pagetables\":0,\"swapcached\":0,\"commitlimit\":0,\"committedas\":0,\"hightotal\":0,\"highfree\":0,\"lowtotal\":0,\"lowfree\":0,\"swaptotal\":0,\"swapfree\":0,\"mapped\":0,\"vmalloctotal\":0,\"vmallocused\":0,\"vmallocchunk\":0,\"hugepagestotal\":0,\"hugepagesfree\":0,\"hugepagesize\":0} 单位为字节，我的电脑内存 8GB，当前使用百分比为 55%，可用内存 3768975360B（即 3.51GB）。 CPU 我们知道 CPU 的核数有两种，一种是物理核数，一种是逻辑核数。物理核数就是主板上实际有多少个 CPU，一个物理 CPU 上可以有多个核心，这些核心被称为逻辑核。gopsutil中 CPU 相关功能在cpu子包中，cpu子包提供了获取物理和逻辑核数、CPU 使用率的接口： Counts(logical bool)：传入false，返回物理核数，传入true，返回逻辑核数； Percent(interval time.Duration, percpu bool)：表示获取interval时间间隔内的 CPU 使用率，percpu为false时，获取总的 CPU 使用率，percpu为true时，分别获取每个 CPU 的使用率，返回一个[]float64类型的值。 例如： func main() { physicalCnt, _ := cpu.Counts(false) logicalCnt, _ := cpu.Counts(true) fmt.Printf(\"physical count:%d logical count:%d\\n\", physicalCnt, logicalCnt) totalPercent, _ := cpu.Percent(3*time.Second, false) perPercents, _ := cpu.Percent(3*time.Second, true) fmt.Printf(\"total percent:%v per percents:%v\", totalPercent, perPercents) } 上面代码获取物理核数和逻辑核数，并获取 3s 内的总 CPU 使用率和每个 CPU 各自的使用率，程序输出（注意每次运行输出可能都不相同）： physical count:4 logical count:8 total percent:[30.729166666666668] per percents:[32.64248704663213 26.94300518134715 44.559585492227974 23.958333333333336 36.787564766839374 20.3125 38.54166666666667 28.125] 详细信息调用cpu.Info()可获取 CPU 的详细信息，返回[]cpu.InfoStat： func main() { infos, _ := cpu.Info() for _, info := range infos { data, _ := json.MarshalIndent(info, \"\", \" \") fmt.Print(string(data)) } } 为了方便查看，我使用 JSON 输出结果： { \"cpu\": 0, \"vendorId\": \"GenuineIntel\", \"family\": \"198\", \"model\": \"\", \"stepping\": 0, \"physicalId\": \"BFEBFBFF000906E9\", \"coreId\": \"\", \"cores\": 8, \"modelName\": \"Intel(R) Core(TM) i7-7700 CPU @ 3.60GHz\", \"mhz\": 3601, \"cacheSize\": 0, \"flags\": [], \"microcode\": \"\" } 由结果可以看出，CPU 是 Intel 的 i7-7700 系列，频率 3.60GHz。上面是我在 Windows 上运行的返回结果，内部使用了github.com/StackExchange/wmi库。在 Linux 下每个逻辑 CPU 都会返回一个InfoStat结构。 时间占用 调用cpu.Times(percpu bool)可以获取从开机算起，总 CPU 和 每个单独的 CPU 时间占用情况。传入percpu=false返回总的，传入percpu=true返回单个的。每个 CPU 时间占用情况是一个TimeStat结构： // src/github.com/shirou/gopsutil/cpu/cpu.go type TimesStat struct { CPU string `json:\"cpu\"` User float64 `json:\"user\"` System float64 `json:\"system\"` Idle float64 `json:\"idle\"` Nice float64 `json:\"nice\"` Iowait float64 `json:\"iowait\"` Irq float64 `json:\"irq\"` Softirq float64 `json:\"softirq\"` Steal float64 `json:\"steal\"` Guest float64 `json:\"guest\"` GuestNice float64 `json:\"guestNice\"` } CPU：CPU 标识，如果是总的，该字段为cpu-total，否则为cpu0、cpu1…； User：用户时间占用（用户态）； System：系统时间占用（内核态）； Idle：空闲时间； … 例如： func main() { infos, _ := cpu.Times(true) for _, info := range infos { data, _ := json.MarshalIndent(info, \"\", \" \") fmt.Print(string(data)) } } 为了方便查看，我用 JSON 输出结果，下面是其中一个输出： { \"cpu\": \"cpu0\", \"user\": 674.46875, \"system\": 1184.984375, \"idle\": 7497.1875, \"nice\": 0, \"iowait\": 0, \"irq\": 75.578125, \"softirq\": 0, \"steal\": 0, \"guest\": 0, \"guestNice\": 0 } 磁盘 子包disk用于获取磁盘信息。disk可获取 IO 统计、分区和使用率信息。下面依次介绍。 IO 统计 调用disk.IOCounters()函数，返回的 IO 统计信息用map[string]IOCountersStat类型表示。每个分区一个结构，键为分区名，值为统计信息。这里摘取统计","date":"2023-11-11","objectID":"/posts/2023-11-11-gopsutil/:1:2","tags":["Go","gopsutil"],"title":"Go gopsutil","uri":"/posts/2023-11-11-gopsutil/"},{"categories":["Go 库文档"],"content":"Go 读取yaml格式配置文件 package config import ( \"fmt\" \"io/ioutil\" \"gopkg.in/yaml.v3\" ) type Service struct { Host string `json:\"host\" yaml:\"host\"` Port string `json:\"port\" yaml:\"port\"` } type MyConfig struct { Service Service `json:\"service\" yaml:\"service\"` } var Config *MyConfig func LoadConfig(filepath string) { if filepath == \"\" { return } // 读yaml文件 config, err := ioutil.ReadFile(filepath) if err != nil { fmt.Printf(\"read config failed, please check the path: %v , err: %v\", filepath, err) } err = yaml.Unmarshal(config, \u0026Config) if err != nil { fmt.Printf(\"Unmarshal to struct, err: %v\", err) } fmt.Printf(\"LoadConfig: %v\", Config) } // 写yaml文件 data, err := yaml.Marshal(SkopeoData) if err != nil { slog.Error(\"yaml marshal failed\", \"err\", err) return } err = os.WriteFile(config.AutoSyncfile, data, 0644) if err != nil { slog.Error(\"Write auto sync data to file failed\", \"err\", err) } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-yaml/:1:0","tags":["Go","yaml"],"title":"Go yaml","uri":"/posts/2023-11-11-go-yaml/"},{"categories":["Go 库文档"],"content":"Go语言内置包之strconv Go语言中strconv包实现了基本数据类型和其字符串表示的相互转换。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-strconv/:0:0","tags":["Go","strconv"],"title":"Go strconv","uri":"/posts/2023-11-11-go-strconv/"},{"categories":["Go 库文档"],"content":"strconv包 strconv包实现了基本数据类型与其字符串表示的转换，主要有以下常用函数： Atoi()、Itia()、parse系列、format系列、append系列。 更多函数请查看官方文档。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-strconv/:0:1","tags":["Go","strconv"],"title":"Go strconv","uri":"/posts/2023-11-11-go-strconv/"},{"categories":["Go 库文档"],"content":"string与int类型转换 这一组函数是我们平时编程中用的最多的。 Atoi() Atoi()函数用于将字符串类型的整数转换为int类型，函数签名如下。 func Atoi(s string) (i int, err error) 如果传入的字符串参数无法转换为int类型，就会返回错误。 s1 := \"100\" i1, err := strconv.Atoi(s1) if err != nil { fmt.Println(\"can't convert to int\") } else { fmt.Printf(\"type:%T value:%#v\\n\", i1, i1) //type:int value:100 } Itoa() Itoa()函数用于将int类型数据转换为对应的字符串表示，具体的函数签名如下。 func Itoa(i int) string 示例代码如下： i2 := 200 s2 := strconv.Itoa(i2) fmt.Printf(\"type:%T value:%#v\\n\", s2, s2) //type:string value:\"200\" a的典故 【扩展阅读】这是C语言遗留下的典故。C语言中没有string类型而是用字符数组(array)表示字符串，所以Itoa对很多C系的程序员很好理解。 Parse系列函数 Parse类函数用于转换字符串为给定类型的值：ParseBool()、ParseFloat()、ParseInt()、ParseUint()。 ParseBool() func ParseBool(str string) (value bool, err error) 返回字符串表示的bool值。它接受1、0、t、f、T、F、true、false、True、False、TRUE、FALSE；否则返回错误。 ParseInt() func ParseInt(s string, base int, bitSize int) (i int64, err error) 返回字符串表示的整数值，接受正负号。 base指定进制（2到36），如果base为0，则会从字符串前置判断，”0x”是16进制，”0”是8进制，否则是10进制； bitSize指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64； 返回的err是*NumErr类型的，如果语法有误，err.Error = ErrSyntax；如果结果超出类型范围err.Error = ErrRange。 ParseUnit() func ParseUint(s string, base int, bitSize int) (n uint64, err error) ParseUint类似ParseInt但不接受正负号，用于无符号整型。 ParseFloat() func ParseFloat(s string, bitSize int) (f float64, err error) 解析一个表示浮点数的字符串并返回其值。 如果s合乎语法规则，函数会返回最为接近s表示值的一个浮点数（使用IEEE754规范舍入）。 bitSize指定了期望的接收类型，32是float32（返回值可以不改变精确值的赋值给float32），64是float64； 返回值err是*NumErr类型的，语法有误的，err.Error=ErrSyntax；结果超出表示范围的，返回值f为±Inf，err.Error= ErrRange。 代码示例 b, err := strconv.ParseBool(\"true\") f, err := strconv.ParseFloat(\"3.1415\", 64) i, err := strconv.ParseInt(\"-2\", 10, 64) u, err := strconv.ParseUint(\"2\", 10, 64) 这些函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-strconv/:0:2","tags":["Go","strconv"],"title":"Go strconv","uri":"/posts/2023-11-11-go-strconv/"},{"categories":["Go 库文档"],"content":"Format系列函数 Format系列函数实现了将给定类型数据格式化为string类型数据的功能。 FormatBool() func FormatBool(b bool) string 根据b的值返回”true”或”false”。 FormatInt() func FormatInt(i int64, base int) string 返回i的base进制的字符串表示。base 必须在2到36之间，结果中会使用小写字母’a’到’z’表示大于10的数字。 FormatUint() func FormatUint(i uint64, base int) string 是FormatInt的无符号整数版本。 FormatFloat() func FormatFloat(f float64, fmt byte, prec, bitSize int) string 函数将浮点数表示为字符串并返回。 bitSize表示f的来源类型（32：float32、64：float64），会据此进行舍入。 fmt表示格式：’f’（-ddd.dddd）、’b’（-ddddp±ddd，指数为二进制）、’e’（-d.dddde±dd，十进制指数）、’E’（-d.ddddE±dd，十进制指数）、’g’（指数很大时用’e’格式，否则’f’格式）、’G’（指数很大时用’E’格式，否则’f’格式）。 prec控制精度（排除指数部分）：对’f’、’e’、’E’，它表示小数点后的数字个数；对’g’、’G’，它控制总的数字个数。如果prec 为-1，则代表使用最少数量的、但又必需的数字来表示f。 代码示例 s1 := strconv.FormatBool(true) s2 := strconv.FormatFloat(3.1415, 'E', -1, 64) s3 := strconv.FormatInt(-2, 16) s4 := strconv.FormatUint(2, 16) ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-strconv/:0:3","tags":["Go","strconv"],"title":"Go strconv","uri":"/posts/2023-11-11-go-strconv/"},{"categories":["Go 库文档"],"content":"其他 isPrint() func IsPrint(r rune) bool 返回一个字符是否是可打印的，和unicode.IsPrint一样，r必须是：字母（广义）、数字、标点、符号、ASCII空格。 CanBackquote() func CanBackquote(s string) bool 返回字符串s是否可以不被修改的表示为一个单行的、没有空格和tab之外控制字符的反引号字符串。 其他 除上文列出的函数外，strconv包中还有Append系列、Quote系列等函数。具体用法可查看官方文档。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-strconv/:0:4","tags":["Go","strconv"],"title":"Go strconv","uri":"/posts/2023-11-11-go-strconv/"},{"categories":["Go 库文档"],"content":"Go tail库 实时读取文件内容 go get github.com/hpcloud/tail 示例： package main import ( \"fmt\" \"time\" \"github.com/hpcloud/tail\" ) func main() { fileName := \"./my.log\" config := tail.Config{ ReOpen: true, // 重新打开 Follow: true, // 是否跟随 Location: \u0026tail.SeekInfo{Offset: 0, Whence: 2}, // 从文件的哪个地方开始读 MustExist: false, // 文件不存在不报错 Poll: true, } tails, err := tail.TailFile(fileName, config) if err != nil { fmt.Println(\"tail file failed, err:\", err) return } var ( line *tail.Line ok bool ) for { line, ok = \u003c-tails.Lines if !ok { fmt.Printf(\"tail file close reopen, filename:%s\\n\", tails.Filename) time.Sleep(time.Second) continue } fmt.Println(\"line:\", line.Text) } } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-tail/:1:0","tags":["Go","tail"],"title":"Go tail","uri":"/posts/2023-11-11-go-tail/"},{"categories":["Go 库文档"],"content":"Go语言标准库net包介绍 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-net/:1:0","tags":["Go","net"],"title":"Go net","uri":"/posts/2023-11-11-go-net/"},{"categories":["Go 库文档"],"content":"一、域名解析 DNS 记录是与 DNS 服务器关联的映射文件，无论每个域名与哪个 IP 地址关联，它们都能处理发送到每个域名的请求。net 包包含各种方法来查找 DNS 记录的细节。让我们运行一些示例，收集有关 DNS 服务器的信息以及目标域名的相应记录： 本文是 Go语言中文网组织的 GCTT 翻译，发布在 Go语言中文网公众号，转载请联系我们授权。 1、Go 程序查找域名的 A 记录 net.LookupIP() 函数接受一个字符串（domain-name）并返回一个包含主机的 IPv4 和 IPv6 地址的 net.IP 对象切片。 package main import ( \"fmt\" \"net\" ) func main() { iprecords, _ := net.LookupIP(\"facebook.com\") for _, ip := range iprecords { fmt.Println(ip) } } 上述程序的输出列出了以 IPv4 和 IPv6 格式返回的 facebook.com 的 A 记录。 C:\\golang\\dns\u003e Go run example1.go 2a03:2880:f12f:83:face:b00c:0:25de 31.13.79.35 2、Go 程序查找域名的 CNAME 记录 CNAME 是规范名称的缩写。CNAME 本质上是绑定路径的域名和子域名的文本别名。net.LookupCNAME() 函数接受主机域名（m.facebook.com）作为字符串，并返回给定主机的单个规范域名 package main import ( \"fmt\" \"net\" ) func main() { cname, _ := net.LookupCNAME(\"m.facebook.com\") fmt.Println(cname) } m.facebook.com 域名返回的 CNAME 记录如下所示： C:\\golang\\dns\u003e Go run example2.go star-mini.c10r.facebook.com。 3、Go 程序查找域名的 PTR 指针记录 这些记录提供从地址到名称的反向绑定。PTR 记录应与正向记录完全匹配。net.LookupAddr() 函数对地址执行反向查找，并返回映射到给定地址的名称列表。 package main import ( \"fmt\" \"net\" ) func main() { ptr, _ := net.LookupAddr(\"6.8.8.8\") for _, ptrvalue := range ptr { fmt.Println(ptrvalue) } } 对于给定的地址，上述程序返回单个反向记录，如下所示： C:\\golang\\dns\u003ego run example3.go tms_server.yuma.army.mil. 4、Go 程序查找域名的名称服务器（NS）记录 NS 记录描述了区域的授权名称服务器。NS 还将子域名委托给区域文件上的其他组织。net.LookupNS() 函数将域名（facebook.com）作为字符串，并返回 DNS-NS 记录作为 NS 结构的切片。 package main import ( \"fmt\" \"net\" ) func main() { nameserver, _ := net.LookupNS(\"facebook.com\") for _, ns := range nameserver { fmt.Println(ns) } } 支持该域名的 NS 记录如下所示： C:\\golang\\dns\u003ego run example4.go \u0026{a.ns.facebook.com.} \u0026{b.ns.facebook.com.} 5、Go 程序查找域的 MX 记录 这些记录用来记录可以交换电子邮件的服务器。net.LookupMX() 函数将域名作为字符串，并返回按首选项排序的 MX 结构切片。MX 结构由类型为字符串的 HOST 和 类型为 uint16 的 Pref 组成。 package main import ( \"fmt\" \"net\" ) func main() { mxrecords, _ := net.LookupMX(\"facebook.com\") for _, mx := range mxrecords { fmt.Println(mx.Host, mx.Pref) } } 域名（facebook.com）的输出列表 MX 记录。 C:\\golang\\dns\u003ego run example5.go msgin.vvv.facebook.com. 10 6、Go 程序查找域名的 SRV 服务记录 LookupSRV 函数尝试解析给定服务，协议和域名的 SRV 查询。第二个参数是 “tcp” 或 “udp”。返回的记录按优先级排序，并按照权重随机化。 package main import ( \"fmt\" \"net\" ) func main() { cname, srvs, err := net.LookupSRV(\"xmpp-server\", \"tcp\", \"golang.org\") if err != nil { panic(err) } fmt.Printf(\"\\ncname: %s \\n\\n\", cname) for _, srv := range srvs { fmt.Printf(\"%v:%v:%d:%d\\n\", srv.Target, srv.Port, srv.Priority, srv.Weight) } } 下面的输出演示了 CNAME 返回，后跟由冒号分隔的 SRV 记录的目标，端口，优先级和权重。 C:\\golang\\dns\u003ego run example6.go cname: _xmpp-server._tcp.golang.org. 7、Go 程序查找域名的 TXT 记录 TXT 记录存储有关 SPF 的信息，该信息可以识别授权服务器以代表您的组织发送电子邮件。net.LookupTXT() 函数将域名（facebook.com）作为字符串，并返回 DNS TXT 记录的字符串切片。 package main import ( \"fmt\" \"net\" ) func main() { txtrecords, _ := net.LookupTXT(\"facebook.com\") for _, txt := range txtrecords { fmt.Println(txt) } } gmail.com 的单个 TXT 记录如下所示。 C:\\golang\\dns\u003ego run example7.go v=spf1 redirect=_spf.facebook.com via: http://www.golangprograms.com/find-dns-records-programmatically.html 作者：golangprograms[1]译者：lovechuck[2]校对：polaris1119[3] ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-net/:1:1","tags":["Go","net"],"title":"Go net","uri":"/posts/2023-11-11-go-net/"},{"categories":["Go 库文档"],"content":"参考资料 [1]golangprograms: http://www.golangprograms.com [2]lovechuck: https://github.com/lovechuck [3]polaris1119: https://github.com/polaris1119 [4]GCTT: https://github.com/studygolang/GCTT [5]Go 中文网: https://studygolang.com/ ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-net/:1:2","tags":["Go","net"],"title":"Go net","uri":"/posts/2023-11-11-go-net/"},{"categories":["Go 库文档"],"content":"mapstructure 转换库 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:0","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"简介 mapstructure用于将通用的map[string]interface{}解码到对应的 Go 结构体中，或者执行相反的操作。很多时候，解析来自多种源头的数据流时，我们一般事先并不知道他们对应的具体类型。只有读取到一些字段之后才能做出判断。这时，我们可以先使用标准的encoding/json库将数据解码为map[string]interface{}类型，然后根据标识字段利用mapstructure库转为相应的 Go 结构体以便使用。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:1","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"快速使用 本文代码采用 Go Modules。 首先创建目录并初始化： $ mkdir mapstructure \u0026\u0026 cd mapstructure $ go mod init github.com/darjun/go-daily-lib/mapstructure 下载mapstructure库： $ go get github.com/mitchellh/mapstructure 使用： package main import ( \"encoding/json\" \"fmt\" \"log\" \"github.com/mitchellh/mapstructure\" ) type Person struct { Name string Age int Job string } type Cat struct { Name string Age int Breed string } func main() { datas := []string{` { \"type\": \"person\", \"name\":\"dj\", \"age\":18, \"job\": \"programmer\" } `, ` { \"type\": \"cat\", \"name\": \"kitty\", \"age\": 1, \"breed\": \"Ragdoll\" } `, } for _, data := range datas { var m map[string]interface{} err := json.Unmarshal([]byte(data), \u0026m) if err != nil { log.Fatal(err) } switch m[\"type\"].(string) { case \"person\": var p Person mapstructure.Decode(m, \u0026p) fmt.Println(\"person\", p) case \"cat\": var cat Cat mapstructure.Decode(m, \u0026cat) fmt.Println(\"cat\", cat) } } } 运行结果： $ go run main.go person {dj 18 programmer} cat {kitty 1 Ragdoll} 我们定义了两个结构体Person和Cat，他们的字段有些许不同。现在，我们约定通信的 JSON 串中有一个type字段。当type的值为person时，该 JSON 串表示的是Person类型的数据。当type的值为cat时，该 JSON 串表示的是Cat类型的数据。 上面代码中，我们先用json.Unmarshal将字节流解码为map[string]interface{}类型。然后读取里面的type字段。根据type字段的值，再使用mapstructure.Decode将该 JSON 串分别解码为Person和Cat类型的值，并输出。 实际上，Google Protobuf 通常也使用这种方式。在协议中添加消息 ID 或全限定消息名。接收方收到数据后，先读取协议 ID 或全限定消息名。然后调用 Protobuf 的解码方法将其解码为对应的Message结构。从这个角度来看，mapstructure也可以用于网络消息解码，如果你不考虑性能的话😄。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:2","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"字段标签 默认情况下，mapstructure使用结构体中字段的名称做这个映射，例如我们的结构体有一个Name字段，mapstructure解码时会在map[string]interface{}中查找键名name。注意，这里的name是大小写不敏感的！ type Person struct { Name string } 当然，我们也可以指定映射的字段名。为了做到这一点，我们需要为字段设置mapstructure标签。例如下面使用username代替上例中的name： type Person struct { Name string `mapstructure:\"username\"` } 看示例： type Person struct { Name string `mapstructure:\"username\"` Age int Job string } type Cat struct { Name string Age int Breed string } func main() { datas := []string{` { \"type\": \"person\", \"username\":\"dj\", \"age\":18, \"job\": \"programmer\" } `, ` { \"type\": \"cat\", \"name\": \"kitty\", \"Age\": 1, \"breed\": \"Ragdoll\" } `, ` { \"type\": \"cat\", \"Name\": \"rooooose\", \"age\": 2, \"breed\": \"shorthair\" } `, } for _, data := range datas { var m map[string]interface{} err := json.Unmarshal([]byte(data), \u0026m) if err != nil { log.Fatal(err) } switch m[\"type\"].(string) { case \"person\": var p Person mapstructure.Decode(m, \u0026p) fmt.Println(\"person\", p) case \"cat\": var cat Cat mapstructure.Decode(m, \u0026cat) fmt.Println(\"cat\", cat) } } } 上面代码中，我们使用标签mapstructure:\"username\"将Person的Name字段映射为username，在 JSON 串中我们需要设置username才能正确解析。另外，注意到，我们将第二个 JSON 串中的Age和第三个 JSON 串中的Name首字母大写了，但是并没有影响解码结果。mapstructure处理字段映射是大小写不敏感的。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:3","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"内嵌结构 结构体可以任意嵌套，嵌套的结构被认为是拥有该结构体名字的另一个字段。例如，下面两种Friend的定义方式对于mapstructure是一样的： type Person struct { Name string } // 方式一 type Friend struct { Person } // 方式二 type Friend struct { Person Person } 为了正确解码，Person结构的数据要在person键下： map[string]interface{} { \"person\": map[string]interface{}{\"name\": \"dj\"}, } 我们也可以设置mapstructure:\",squash\"将该结构体的字段提到父结构中： type Friend struct { Person `mapstructure:\",squash\"` } 这样只需要这样的 JSON 串，无效嵌套person键： map[string]interface{}{ \"name\": \"dj\", } 看示例： type Person struct { Name string } type Friend1 struct { Person } type Friend2 struct { Person `mapstructure:\",squash\"` } func main() { datas := []string{` { \"type\": \"friend1\", \"person\": { \"name\":\"dj\" } } `, ` { \"type\": \"friend2\", \"name\": \"dj2\" } `, } for _, data := range datas { var m map[string]interface{} err := json.Unmarshal([]byte(data), \u0026m) if err != nil { log.Fatal(err) } switch m[\"type\"].(string) { case \"friend1\": var f1 Friend1 mapstructure.Decode(m, \u0026f1) fmt.Println(\"friend1\", f1) case \"friend2\": var f2 Friend2 mapstructure.Decode(m, \u0026f2) fmt.Println(\"friend2\", f2) } } } 注意对比Friend1和Friend2使用的 JSON 串的不同。 另外需要注意一点，如果父结构体中有同名的字段，那么mapstructure会将JSON 中对应的值同时设置到这两个字段中，即这两个字段有相同的值。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:4","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"未映射的值 如果源数据中有未映射的值（即结构体中无对应的字段），mapstructure默认会忽略它。 我们可以在结构体中定义一个字段，为其设置mapstructure:\",remain\"标签。这样未映射的值就会添加到这个字段中。注意，这个字段的类型只能为map[string]interface{}或map[interface{}]interface{}。 看示例： type Person struct { Name string Age int Job string Other map[string]interface{} `mapstructure:\",remain\"` } func main() { data := ` { \"name\": \"dj\", \"age\":18, \"job\":\"programmer\", \"height\":\"1.8m\", \"handsome\": true } ` var m map[string]interface{} err := json.Unmarshal([]byte(data), \u0026m) if err != nil { log.Fatal(err) } var p Person mapstructure.Decode(m, \u0026p) fmt.Println(\"other\", p.Other) } 上面代码中，我们为结构体定义了一个Other字段，用于保存未映射的键值。输出结果： other map[handsome:true height:1.8m] ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:5","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"逆向转换 前面我们都是将map[string]interface{}解码到 Go 结构体中。mapstructure当然也可以将 Go 结构体反向解码为map[string]interface{}。在反向解码时，我们可以为某些字段设置mapstructure:\",omitempty\"。这样当这些字段为默认值时，就不会出现在结构的map[string]interface{}中： type Person struct { Name string Age int Job string `mapstructure:\",omitempty\"` } func main() { p := \u0026Person{ Name: \"dj\", Age: 18, } var m map[string]interface{} mapstructure.Decode(p, \u0026m) data, _ := json.Marshal(m) fmt.Println(string(data)) } 上面代码中，我们为Job字段设置了mapstructure:\",omitempty\"，且对象p的Job字段未设置。运行结果： $ go run main.go {\"Age\":18,\"Name\":\"dj\"} ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:6","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"Metadata 解码时会产生一些有用的信息，mapstructure可以使用Metadata收集这些信息。Metadata结构如下： // mapstructure.go type Metadata struct { Keys []string Unused []string } Metadata只有两个导出字段： Keys：解码成功的键名； Unused：在源数据中存在，但是目标结构中不存在的键名。 为了收集这些数据，我们需要使用DecodeMetadata来代替Decode方法： type Person struct { Name string Age int } func main() { m := map[string]interface{}{ \"name\": \"dj\", \"age\": 18, \"job\": \"programmer\", } var p Person var metadata mapstructure.Metadata mapstructure.DecodeMetadata(m, \u0026p, \u0026metadata) fmt.Printf(\"keys:%#v unused:%#v\\n\", metadata.Keys, metadata.Unused) } 先定义一个Metadata结构，传入DecodeMetadata收集解码的信息。运行结果： $ go run main.go keys:[]string{\"Name\", \"Age\"} unused:[]string{\"job\"} ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:7","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"错误处理 mapstructure执行转换的过程中不可避免地会产生错误，例如 JSON 中某个键的类型与对应 Go 结构体中的字段类型不一致。Decode/DecodeMetadata会返回这些错误： type Person struct { Name string Age int Emails []string } func main() { m := map[string]interface{}{ \"name\": 123, \"age\": \"bad value\", \"emails\": []int{1, 2, 3}, } var p Person err := mapstructure.Decode(m, \u0026p) if err != nil { fmt.Println(err.Error()) } } 上面代码中，结构体中Person中字段Name为string类型，但输入中name为int类型；字段Age为int类型，但输入中age为string类型；字段Emails为[]string类型，但输入中emails为[]int类型。故Decode返回错误。运行结果： $ go run main.go 5 error(s) decoding: * 'Age' expected type 'int', got unconvertible type 'string' * 'Emails[0]' expected type 'string', got unconvertible type 'int' * 'Emails[1]' expected type 'string', got unconvertible type 'int' * 'Emails[2]' expected type 'string', got unconvertible type 'int' * 'Name' expected type 'string', got unconvertible type 'int' 从错误信息中很容易看出哪里出错了。 弱类型输入 有时候，我们并不想对结构体字段类型和map[string]interface{}的对应键值做强类型一致的校验。这时可以使用WeakDecode/WeakDecodeMetadata方法，它们会尝试做类型转换： type Person struct { Name string Age int Emails []string } func main() { m := map[string]interface{}{ \"name\": 123, \"age\": \"18\", \"emails\": []int{1, 2, 3}, } var p Person err := mapstructure.WeakDecode(m, \u0026p) if err == nil { fmt.Println(\"person:\", p) } else { fmt.Println(err.Error()) } } 虽然键name对应的值123是int类型，但是在WeakDecode中会将其转换为string类型以匹配Person.Name字段的类型。同样的，age的值\"18\"是string类型，在WeakDecode中会将其转换为int类型以匹配Person.Age字段的类型。 需要注意一点，如果类型转换失败了，WeakDecode同样会返回错误。例如将上例中的age设置为\"bad value\"，它就不能转为int类型，故而返回错误。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:8","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"解码器 除了上面介绍的方法外，mapstructure还提供了更灵活的解码器（Decoder）。可以通过配置DecoderConfig实现上面介绍的任何功能： // mapstructure.go type DecoderConfig struct { ErrorUnused bool ZeroFields bool WeaklyTypedInput bool Metadata *Metadata Result interface{} TagName string } 各个字段含义如下： ErrorUnused：为true时，如果输入中的键值没有与之对应的字段就返回错误； ZeroFields：为true时，在Decode前清空目标map。为false时，则执行的是map的合并。用在struct到map的转换中； WeaklyTypedInput：实现WeakDecode/WeakDecodeMetadata的功能； Metadata：不为nil时，收集Metadata数据； Result：为结果对象，在map到struct的转换中，Result为struct类型。在struct到map的转换中，Result为map类型； TagName：默认使用mapstructure作为结构体的标签名，可以通过该字段设置。 看示例： type Person struct { Name string Age int } func main() { m := map[string]interface{}{ \"name\": 123, \"age\": \"18\", \"job\": \"programmer\", } var p Person var metadata mapstructure.Metadata decoder, err := mapstructure.NewDecoder(\u0026mapstructure.DecoderConfig{ WeaklyTypedInput: true, Result: \u0026p, Metadata: \u0026metadata, }) if err != nil { log.Fatal(err) } err = decoder.Decode(m) if err == nil { fmt.Println(\"person:\", p) fmt.Printf(\"keys:%#v, unused:%#v\\n\", metadata.Keys, metadata.Unused) } else { fmt.Println(err.Error()) } } 这里用Decoder的方式实现了前面弱类型输入小节中的示例代码。实际上WeakDecode内部就是通过这种方式实现的，下面是WeakDecode的源码： // mapstructure.go func WeakDecode(input, output interface{}) error { config := \u0026DecoderConfig{ Metadata: nil, Result: output, WeaklyTypedInput: true, } decoder, err := NewDecoder(config) if err != nil { return err } return decoder.Decode(input) } 再实际上，Decode/DecodeMetadata/WeakDecodeMetadata内部都是先设置DecoderConfig的对应字段，然后创建Decoder对象，最后调用其Decode方法实现的。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-mapstructure/:1:9","tags":["Go","mapstructure"],"title":"Go mapstructure","uri":"/posts/2023-11-11-go-mapstructure/"},{"categories":["Go 库文档"],"content":"Go leveldb库 github地址：https://github.com/syndtr/goleveldb 安装： go get github.com/syndtr/goleveldb/leveldb ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-leveldb/:1:0","tags":["Go","leveldb"],"title":"Go leveldb","uri":"/posts/2023-11-11-go-leveldb/"},{"categories":["Go 库文档"],"content":"简介： levelDB在区块链中比较常用，其是Google开源的持久化单机Key-Value文件数据库，其支持按照文件大小切分文件的功能。levelDB具有很高的随机写，顺序读/写性能，但是随机读的性能很一般，也就是说，levelDB很适合应用在查询较少，而写很多的场景。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-leveldb/:1:1","tags":["Go","leveldb"],"title":"Go leveldb","uri":"/posts/2023-11-11-go-leveldb/"},{"categories":["Go 库文档"],"content":"LevelDB特点 1）key和value都是任意长度的字节数组； 2）entry（即一条k-v记录）默认是按照key的字典顺序存储的，开发者也可以重写这个方法； 3）提供了基本的增删改查接口； 4）支持批量操作以原子操作进行； 5）开源创建数据全景的snapshot（快照），并允许在快照中查询； 6）开源通过向前（后）迭代器遍历数据（迭代器隐含的创建了一个snapshot）； 7）自动使用Snappy压缩数据； 8）可移植性。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-leveldb/:1:2","tags":["Go","leveldb"],"title":"Go leveldb","uri":"/posts/2023-11-11-go-leveldb/"},{"categories":["Go 库文档"],"content":"levelDB限制 1）NoSQL，不支持sql语句，也不支持索引； 2）一次只允许一个进程访问一个特定的数据库； 3）没有内置的C/S架构，开发者需要使用levelDB库自己封装一个server； ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-leveldb/:1:3","tags":["Go","leveldb"],"title":"Go leveldb","uri":"/posts/2023-11-11-go-leveldb/"},{"categories":["Go 库文档"],"content":"使用： 1）打开、创建数据库 db, err := leveldb.OpenFile(\"./block.db\", nil) 2）写入key数据 err = db.Put([]byte(\"hello\"), []byte(\"world\"), nil) 3）读取key数据 data, _ := db.Get([]byte(\"hello\"), nil) 4）遍历数据库 iter := db.NewIterator(nil, nil) for iter.Next() { logger.Debug(iter.Key() + iter.Value()) } 5）读取某个前缀的所有KEY数据 读出来的数据会被放进一个Iterator中。加入数据库现在有key-$num为头的数条数据 iter := db.NewIterator(dbUtil.BytesPrefix([]byte(\"key-\")), nil) 遍历读取这些数据 for iter.Next() { logger.Debug(string(iter.Key()) + string(iter.Value())) } 读取最后一条数据 if iter.Last() { logger.Debug(iter.Key() + iter.Value()) } 6）删除某个KEY err = db.Delete([]byte(\"key-3\"), nil) 7）批量写 batch := new(leveldb.Batch) batch.Put([]byte(\"foo\"), []byte(\"value\")) batch.Put([]byte(\"bar\"), []byte(\"another value\")) batch.Delete([]byte(\"baz\")) err = db.Write(batch, nil) ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-leveldb/:1:4","tags":["Go","leveldb"],"title":"Go leveldb","uri":"/posts/2023-11-11-go-leveldb/"},{"categories":["Go 库文档"],"content":"Go ini库 参考：https://juejin.cn/post/6844904048764649479 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:0","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"简介 ini 是 Windows 上常用的配置文件格式。MySQL 的 Windows 版就是使用 ini 格式存储配置的。 go-ini是 Go 语言中用于操作 ini 文件的第三方库。 本文介绍go-ini库的使用。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:1","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"快速使用 go-ini 是第三方库，使用前需要安装： $ go get gopkg.in/ini.v1 也可以使用 GitHub 上的仓库： $ go get github.com/go-ini/ini 首先，创建一个my.ini配置文件： app_name = awesome web # possible values: DEBUG, INFO, WARNING, ERROR, FATAL log_level = DEBUG [mysql] ip = 127.0.0.1 port = 3306 user = dj password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 使用 go-ini 库读取： package main import ( \"fmt\" \"log\" \"gopkg.in/ini.v1\" ) func main() { cfg, err := ini.Load(\"my.ini\") if err != nil { log.Fatal(\"Fail to read file: \", err) } fmt.Println(\"App Name:\", cfg.Section(\"\").Key(\"app_name\").String()) fmt.Println(\"Log Level:\", cfg.Section(\"\").Key(\"log_level\").String()) fmt.Println(\"MySQL IP:\", cfg.Section(\"mysql\").Key(\"ip\").String()) mysqlPort, err := cfg.Section(\"mysql\").Key(\"port\").Int() if err != nil { log.Fatal(err) } fmt.Println(\"MySQL Port:\", mysqlPort) fmt.Println(\"MySQL User:\", cfg.Section(\"mysql\").Key(\"user\").String()) fmt.Println(\"MySQL Password:\", cfg.Section(\"mysql\").Key(\"password\").String()) fmt.Println(\"MySQL Database:\", cfg.Section(\"mysql\").Key(\"database\").String()) fmt.Println(\"Redis IP:\", cfg.Section(\"redis\").Key(\"ip\").String()) redisPort, err := cfg.Section(\"redis\").Key(\"port\").Int() if err != nil { log.Fatal(err) } fmt.Println(\"Redis Port:\", redisPort) } 在 ini 文件中，每个键值对占用一行，中间使用=隔开。以#开头的内容为注释。ini 文件是以分区（section）组织的。 分区以[name]开始，在下一个分区前结束。所有分区前的内容属于默认分区，如my.ini文件中的app_name和log_level。 使用go-ini读取配置文件的步骤如下： 首先调用ini.Load加载文件，得到配置对象cfg； 然后以分区名调用配置对象的Section方法得到对应的分区对象section，默认分区的名字为\"\"，也可以使用ini.DefaultSection； 以键名调用分区对象的Key方法得到对应的配置项key对象； 由于文件中读取出来的都是字符串，key对象需根据类型调用对应的方法返回具体类型的值使用，如上面的String、MustInt方法。 运行以下程序，得到输出： App Name: awesome web Log Level: DEBUG MySQL IP: 127.0.0.1 MySQL Port: 3306 MySQL User: dj MySQL Password: 123456 MySQL Database: awesome Redis IP: 127.0.0.1 Redis Port: 6381 配置文件中存储的都是字符串，所以类型为字符串的配置项不会出现类型转换失败的，故String()方法只返回一个值。 但如果类型为Int/Uint/Float64这些时，转换可能失败。所以Int()/Uint()/Float64()返回一个值和一个错误。 要留意这种不一致！如果我们将配置中 redis 端口改成非法的数字 x6381，那么运行程序将报错： 2020/01/14 22:43:13 strconv.ParseInt: parsing \"x6381\": invalid syntax 复制代码 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:2","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"Must*便捷方法 如果每次取值都需要进行错误判断，那么代码写起来会非常繁琐。为此，go-ini也提供对应的MustType（Type 为Init/Uint/Float64等）方法，这个方法只返回一个值。 同时它接受可变参数，如果类型无法转换，取参数中第一个值返回，并且该参数设置为这个配置的值，下次调用返回这个值： package main import ( \"fmt\" \"log\" \"gopkg.in/ini.v1\" ) func main() { cfg, err := ini.Load(\"my.ini\") if err != nil { log.Fatal(\"Fail to read file: \", err) } redisPort, err := cfg.Section(\"redis\").Key(\"port\").Int() if err != nil { fmt.Println(\"before must, get redis port error:\", err) } else { fmt.Println(\"before must, get redis port:\", redisPort) } fmt.Println(\"redis Port:\", cfg.Section(\"redis\").Key(\"port\").MustInt(6381)) redisPort, err = cfg.Section(\"redis\").Key(\"port\").Int() if err != nil { fmt.Println(\"after must, get redis port error:\", err) } else { fmt.Println(\"after must, get redis port:\", redisPort) } } 配置文件还是 redis 端口为非数字 x6381 时的状态，运行程序： before must, get redis port error: strconv.ParseInt: parsing \"x6381\": invalid syntax redis Port: 6381 after must, get redis port: 6381 复制代码 我们看到第一次调用Int返回错误，以 6381 为参数调用MustInt之后，再次调用Int，成功返回 6381。MustInt源码也比较简单： // gopkg.in/ini.v1/key.go func (k *Key) MustInt(defaultVal ...int) int { val, err := k.Int() if len(defaultVal) \u003e 0 \u0026\u0026 err != nil { k.value = strconv.FormatInt(int64(defaultVal[0]), 10) return defaultVal[0] } return val } 复制代码 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:3","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"分区操作 获取信息 在加载配置之后，可以通过Sections方法获取所有分区，SectionStrings()方法获取所有分区名。 sections := cfg.Sections() names := cfg.SectionStrings() fmt.Println(\"sections: \", sections) fmt.Println(\"names: \", names) 复制代码 运行输出 3 个分区： [DEFAULT mysql redis] 复制代码 调用Section(name)获取名为name的分区，如果该分区不存在，则自动创建一个分区返回： newSection := cfg.Section(\"new\") fmt.Println(\"new section: \", newSection) fmt.Println(\"names: \", cfg.SectionStrings()) 创建之后调用SectionStrings方法，新分区也会返回： names: [DEFAULT mysql redis new] 也可以手动创建一个新分区，如果分区已存在，则返回错误： err := cfg.NewSection(\"new\") 父子分区 在配置文件中，可以使用占位符%(name)s表示用之前已定义的键name的值来替换，这里的s表示值为字符串类型： NAME = ini VERSION = v1 IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s [package] CLONE_URL = https://%(IMPORT_PATH)s [package.sub] 上面在默认分区中设置IMPORT_PATH的值时，使用了前面定义的NAME和VERSION。 在package分区中设置CLONE_URL的值时，使用了默认分区中定义的IMPORT_PATH。 我们还可以在分区名中使用.表示两个或多个分区之间的父子关系，例如package.sub的父分区为package，package的父分区为默认分区。 如果某个键在子分区中不存在，则会在它的父分区中再次查找，直到没有父分区为止： cfg, err := ini.Load(\"parent_child.ini\") if err != nil { fmt.Println(\"Fail to read file: \", err) return } fmt.Println(\"Clone url from package.sub:\", cfg.Section(\"package.sub\").Key(\"CLONE_URL\").String()) 运行程序输出： Clone url from package.sub: https://gopkg.in/ini.v1 子分区中package.sub中没有键CLONE_URL，返回了父分区package中的值。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:4","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"保存配置 有时候，我们需要将生成的配置写到文件中。例如在写工具的时候。保存有两种类型的接口，一种直接保存到文件，另一种写入到io.Writer中： err = cfg.SaveTo(\"my.ini\") err = cfg.SaveToIndent(\"my.ini\", \"\\t\") cfg.WriteTo(writer) cfg.WriteToIndent(writer, \"\\t\") 下面我们通过程序生成前面使用的配置文件my.ini并保存： package main import ( \"fmt\" \"os\" \"gopkg.in/ini.v1\" ) func main() { cfg := ini.Empty() defaultSection := cfg.Section(\"\") defaultSection.NewKey(\"app_name\", \"awesome web\") defaultSection.NewKey(\"log_level\", \"DEBUG\") mysqlSection, err := cfg.NewSection(\"mysql\") if err != nil { fmt.Println(\"new mysql section failed:\", err) return } mysqlSection.NewKey(\"ip\", \"127.0.0.1\") mysqlSection.NewKey(\"port\", \"3306\") mysqlSection.NewKey(\"user\", \"root\") mysqlSection.NewKey(\"password\", \"123456\") mysqlSection.NewKey(\"database\", \"awesome\") redisSection, err := cfg.NewSection(\"redis\") if err != nil { fmt.Println(\"new redis section failed:\", err) return } redisSection.NewKey(\"ip\", \"127.0.0.1\") redisSection.NewKey(\"port\", \"6381\") err = cfg.SaveTo(\"my.ini\") if err != nil { fmt.Println(\"SaveTo failed: \", err) } err = cfg.SaveToIndent(\"my-pretty.ini\", \"\\t\") if err != nil { fmt.Println(\"SaveToIndent failed: \", err) } cfg.WriteTo(os.Stdout) fmt.Println() cfg.WriteToIndent(os.Stdout, \"\\t\") } 运行程序，生成两个文件my.ini和my-pretty.ini，同时控制台输出文件内容。 my.ini： app_name = awesome web log_level = DEBUG [mysql] ip = 127.0.0.1 port = 3306 user = root password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 my-pretty.ini： app_name = awesome web log_level = DEBUG [mysql] ip = 127.0.0.1 port = 3306 user = root password = 123456 database = awesome [redis] ip = 127.0.0.1 port = 6381 *Indent方法会对子分区下的键增加缩进，看起来美观一点。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:5","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"分区与结构体字段映射 定义结构变量，加载完配置文件后，调用MapTo将配置项赋值到结构变量的对应字段中。 package main import ( \"fmt\" \"gopkg.in/ini.v1\" ) type Config struct { AppName string `ini:\"app_name\"` LogLevel string `ini:\"log_level\"` MySQL MySQLConfig `ini:\"mysql\"` Redis RedisConfig `ini:\"redis\"` } type MySQLConfig struct { IP string `ini:\"ip\"` Port int `ini:\"port\"` User string `ini:\"user\"` Password string `ini:\"password\"` Database string `ini:\"database\"` } type RedisConfig struct { IP string `ini:\"ip\"` Port int `ini:\"port\"` } func main() { cfg, err := ini.Load(\"my.ini\") if err != nil { fmt.Println(\"load my.ini failed: \", err) } c := Config{} cfg.MapTo(\u0026c) fmt.Println(c) } MapTo内部使用了反射，所以结构体字段必须都是导出的。如果键名与字段名不相同，那么需要在结构标签中指定对应的键名。 这一点与 Go 标准库encoding/json和encoding/xml不同。标准库json/xml解析时可以将键名app_name对应到字段名AppName。 或许这是go-ini库可以优化的点？ 先加载，再映射有点繁琐，直接使用ini.MapTo将两步合并： err = ini.MapTo(\u0026c, \"my.ini\") 复制代码 也可以只映射一个分区： mysqlCfg := MySQLConfig{} err = cfg.Section(\"mysql\").MapTo(\u0026mysqlCfg) 还可以通过结构体生成配置： cfg := ini.Empty() c := Config { AppName: \"awesome web\", LogLevel: \"DEBUG\", MySQL: MySQLConfig { IP: \"127.0.0.1\", Port: 3306, User: \"root\", Password:\"123456\", Database:\"awesome\", }, Redis: RedisConfig { IP: \"127.0.0.1\", Port: 6381, }, } err := ini.ReflectFrom(cfg, \u0026c) if err != nil { fmt.Println(\"ReflectFrom failed: \", err) return } err = cfg.SaveTo(\"my-copy.ini\") if err != nil { fmt.Println(\"SaveTo failed: \", err) return } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:6","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"总结 本文介绍了go-ini库的基本用法和一些有趣的特性。示例代码已上传GitHub。 其实go-ini还有很多高级特性。官方文档非常详细，推荐去看，而且有中文哟~ 作者无闻，相信做 Go 开发的都不陌生。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:7","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"参考 go-ini GitHub 仓库 go-ini 官方文档 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-ini/:1:8","tags":["Go","ini"],"title":"Go ini","uri":"/posts/2023-11-11-go-ini/"},{"categories":["Go 库文档"],"content":"homedir家目录 GitHub地址：https://github.com/mitchellh/go-homedir 使用os/user获取用户家目录： package main import ( \"fmt\" \"log\" \"os/user\" ) func main() { u, err := user.Current() if err != nil { log.Fatal(err) } fmt.Println(\"Home dir:\", u.HomeDir) } 那么为什么还要go-homedir库？ 在 Darwin 系统上，标准库os/user的使用需要 cgo。所以，任何使用os/user的代码都不能交叉编译。 但是，大多数人使用os/user的目的仅仅只是想获取主目录。因此，go-homedir库出现了。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-homedir/:1:0","tags":["Go","homedir"],"title":"Go homedir","uri":"/posts/2023-11-11-go-homedir/"},{"categories":["Go 库文档"],"content":"快速使用 go-homedir是第三方包，使用前需要先安装： $ go get github.com/mitchellh/go-homedir 使用非常简单： package main import ( \"fmt\" \"log\" \"github.com/mitchellh/go-homedir\" ) func main() { dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\"Home dir:\", dir) dir = \"~/golang/src\" expandedDir, err := homedir.Expand(dir) if err != nil { log.Fatal(err) } fmt.Printf(\"Expand of %s is: %s\\n\", dir, expandedDir) } go-homedir有两个功能： Dir：获取用户主目录； Expand：将路径中的第一个~扩展成用户主目录。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-homedir/:1:1","tags":["Go","homedir"],"title":"Go homedir","uri":"/posts/2023-11-11-go-homedir/"},{"categories":["Go 库文档"],"content":"高级用法 由于Dir的调用可能涉及一些系统调用和外部执行命令，多次调用费性能。所以go-homedir提供了缓存的功能。默认情况下，缓存是开启的。 我们也可以将DisableCache设置为false来关闭它。 package main import ( \"fmt\" \"log\" \"github.com/mitchellh/go-homedir\" ) func main() { homedir.DisableCache = false dir, err := homedir.Dir() if err != nil { log.Fatal(err) } fmt.Println(\"Home dir:\", dir) } 使用缓存时，如果程序运行中修改了主目录，再次调用Dir还是返回之前的目录。如果需要获取最新的主目录，可以先调用Reset清除缓存。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-homedir/:1:2","tags":["Go","homedir"],"title":"Go homedir","uri":"/posts/2023-11-11-go-homedir/"},{"categories":["Go 库文档"],"content":"实现 go-homedir源码只有一个文件homedir.go，今天我们大概看一下Dir的实现，去掉缓存相关代码： func Dir() (string, error) { var result string var err error if runtime.GOOS == \"windows\" { result, err = dirWindows() } else { // Unix-like system, so just assume Unix result, err = dirUnix() } if err != nil { return \"\", err } return result, nil } 判断当前的系统是windows还是类 Unix，分别调用不同的方法。先看 windows 的，比较简单： func dirWindows() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\"HOME\"); home != \"\" { return home, nil } // Prefer standard environment variable USERPROFILE if home := os.Getenv(\"USERPROFILE\"); home != \"\" { return home, nil } drive := os.Getenv(\"HOMEDRIVE\") path := os.Getenv(\"HOMEPATH\") home := drive + path if drive == \"\" || path == \"\" { return \"\", errors.New(\"HOMEDRIVE, HOMEPATH, or USERPROFILE are blank\") } return home, nil } 流程如下： 读取环境变量HOME，如果不为空，返回这个值； 读取环境变量USERPROFILE，如果不为空，返回这个值； 读取环境变量HOMEDRIVE和HOMEPATH，如果两者都不为空，拼接这两个值返回。 类 Unix 系统的实现稍微复杂一点： func dirUnix() (string, error) { homeEnv := \"HOME\" if runtime.GOOS == \"plan9\" { // On plan9, env vars are lowercase. homeEnv = \"home\" } // First prefer the HOME environmental variable if home := os.Getenv(homeEnv); home != \"\" { return home, nil } var stdout bytes.Buffer // If that fails, try OS specific commands if runtime.GOOS == \"darwin\" { cmd := exec.Command(\"sh\", \"-c\", `dscl -q . -read /Users/\"$(whoami)\" NFSHomeDirectory | sed 's/^[^ ]*: //'`) cmd.Stdout = \u0026stdout if err := cmd.Run(); err == nil { result := strings.TrimSpace(stdout.String()) if result != \"\" { return result, nil } } } else { cmd := exec.Command(\"getent\", \"passwd\", strconv.Itoa(os.Getuid())) cmd.Stdout = \u0026stdout if err := cmd.Run(); err != nil { // If the error is ErrNotFound, we ignore it. Otherwise, return it. if err != exec.ErrNotFound { return \"\", err } } else { if passwd := strings.TrimSpace(stdout.String()); passwd != \"\" { // username:password:uid:gid:gecos:home:shell passwdParts := strings.SplitN(passwd, \":\", 7) if len(passwdParts) \u003e 5 { return passwdParts[5], nil } } } } // If all else fails, try the shell stdout.Reset() cmd := exec.Command(\"sh\", \"-c\", \"cd \u0026\u0026 pwd\") cmd.Stdout = \u0026stdout if err := cmd.Run(); err != nil { return \"\", err } result := strings.TrimSpace(stdout.String()) if result == \"\" { return \"\", errors.New(\"blank output when reading home directory\") } return result, nil } 流程如下： 先读取环境变量HOME（注意 plan9 系统上为home），如果不为空，返回这个值； 使用getnet命令查看系统的数据库中的相关记录，我们知道passwd文件中存储了用户信息，包括用户的主目录。使用getent命令查看passwd中当前用户的那条记录，然后从中找到主目录部分返回； 如果上一个步骤失败了，我们知道cd后不加参数是直接切换到用户主目录的，而pwd可以显示当前目录。那么就可以结合这两个命令返回主目录。 这里分析源码并不是表示使用任何库都要熟悉它的源码，毕竟使用库就是为了方便开发。 但是源码是我们学习和提高的一个非常重要的途径。我们在使用库遇到问题的时候也要有能力从文档或甚至源码中查找原因。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-homedir/:1:3","tags":["Go","homedir"],"title":"Go homedir","uri":"/posts/2023-11-11-go-homedir/"},{"categories":["Go 库文档"],"content":"Go Fsnotify库 官方仓库：github.com/fsnotify/fsnotify 用于监控文件或目录的改变 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fsnotify/:1:0","tags":["Go","fsnotify"],"title":"Go fsnotify","uri":"/posts/2023-11-11-go-fsnotify/"},{"categories":["Go 库文档"],"content":"1、官网示例 package main import ( \"log\" \"github.com/fsnotify/fsnotify\" ) func main() { watcher, err := fsnotify.NewWatcher() if err != nil { log.Fatal(err) } defer watcher.Close() done := make(chan bool) go func() { for { select { case event := \u003c-watcher.Events: log.Println(\"event:\", event) if event.Op\u0026fsnotify.Write == fsnotify.Write { log.Println(\"modified file:\", event.Name) } case err := \u003c-watcher.Errors: log.Println(\"error:\", err) } } }() err = watcher.Add(\"/tmp/foo\") if err != nil { log.Fatal(err) } \u003c-done } fsnotify的使用比较简单: 先条用NewWatcher创建一个监听器 然后条用监听器的Add监听文件或目录 如果目录或文件有事件发生，监听器的通道Events可以取出事件。如果出现错误，监听器中的通道Errors可以取出错误信息。 其实，重命名时会产生两个事件，一个是原文件的RENAME事件，一个是新文件的CREATE事件。 注意，fsnotify使用了操作系统接口，监听器中保存了系统资源的句柄，所以使用后需要关闭。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fsnotify/:1:1","tags":["Go","fsnotify"],"title":"Go fsnotify","uri":"/posts/2023-11-11-go-fsnotify/"},{"categories":["Go 库文档"],"content":"2、事件 上面示例中的事件是fsnotify.Event类型： // fsnotify/fsnotify.go type Event struct { Name string Op Op } 事件只有两个字段，Name表示发生变化的文件或目录名，Op表示具体的变化。Op有 5 中取值： // fsnotify/fsnotify.go type Op uint32 const ( Create Op = 1 \u003c\u003c iota Write Remove Rename Chmod ) 3、监控目录 参考链接：https://blog.csdn.net/finghting321/article/details/102852746 package main; import ( \"github.com/fsnotify/fsnotify\" \"fmt\" \"path/filepath\" \"os\" ) type NotifyFile struct { watch *fsnotify.Watcher } func NewNotifyFile() *NotifyFile { w := new(NotifyFile) w.watch, _ = fsnotify.NewWatcher() return w } //监控目录 func (this *NotifyFile) WatchDir(dir string) { //通过Walk来遍历目录下的所有子目录 filepath.Walk(dir, func(path string, info os.FileInfo, err error) error { //判断是否为目录，监控目录,目录下文件也在监控范围内，不需要加 if info.IsDir() { path, err := filepath.Abs(path) if err != nil { return err } err = this.watch.Add(path) if err != nil { return err } fmt.Println(\"监控 : \", path) } return nil }) go this.WatchEvent() //协程 } func (this *NotifyFile) WatchEvent() { for { select { case ev := \u003c-this.watch.Events: { if ev.Op\u0026fsnotify.Create == fsnotify.Create { fmt.Println(\"创建文件 : \", ev.Name) //获取新创建文件的信息，如果是目录，则加入监控中 file, err := os.Stat(ev.Name) if err == nil \u0026\u0026 file.IsDir() { this.watch.Add(ev.Name) fmt.Println(\"添加监控 : \", ev.Name) } } if ev.Op\u0026fsnotify.Write == fsnotify.Write { //fmt.Println(\"写入文件 : \", ev.Name) } if ev.Op\u0026fsnotify.Remove == fsnotify.Remove { fmt.Println(\"删除文件 : \", ev.Name) //如果删除文件是目录，则移除监控 fi, err := os.Stat(ev.Name) if err == nil \u0026\u0026 fi.IsDir() { this.watch.Remove(ev.Name) fmt.Println(\"删除监控 : \", ev.Name) } } if ev.Op\u0026fsnotify.Rename == fsnotify.Rename { //如果重命名文件是目录，则移除监控 ,注意这里无法使用os.Stat来判断是否是目录了 //因为重命名后，go已经无法找到原文件来获取信息了,所以简单粗爆直接remove fmt.Println(\"重命名文件 : \", ev.Name) this.watch.Remove(ev.Name) } if ev.Op\u0026fsnotify.Chmod == fsnotify.Chmod { fmt.Println(\"修改权限 : \", ev.Name) } } case err := \u003c-this.watch.Errors: { fmt.Println(\"error : \", err) return } } } func main() { watch := FSNotify.NewNotifyFile() watch.WatchDir(\"G:\\\\Ferry\") select {} return } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fsnotify/:1:2","tags":["Go","fsnotify"],"title":"Go fsnotify","uri":"/posts/2023-11-11-go-fsnotify/"},{"categories":["Go 库文档"],"content":"Go fmt模块 参考链接：https://www.liwenzhou.com/posts/Go/go_fmt/ fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fmt/:1:0","tags":["Go","fmt"],"title":"Go fmt","uri":"/posts/2023-11-11-go-fmt/"},{"categories":["Go 库文档"],"content":"向外输出 标准库fmt提供了以下几种输出相关函数。 Print Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符串，Println函数会在输出内容的结尾添加一个换行符。 func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) 例如： func main() { fmt.Print(\"在终端打印该信息。\") name := \"沙河小王子\" fmt.Printf(\"我是：%s\\n\", name) fmt.Println(\"在终端打印单独一行显示\") } 输出结果： 在终端打印该信息。我是：沙河小王子 在终端打印单独一行显示 Fprint Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。 func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) 例如： // 向标准输出写入内容 fmt.Fprintln(os.Stdout, \"向标准输出写入内容\") fileObj, err := os.OpenFile(\"./xx.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"打开文件出错，err:\", err) return } name := \"沙河小王子\" // 向打开的文件句柄中写入内容 fmt.Fprintf(fileObj, \"往文件中写如信息：%s\", name) Sprint Sprint系列函数会把传入的数据生成并返回一个字符串。 func Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string 示例： s1 := fmt.Sprint(\"沙河小王子\") name := \"沙河小王子\" age := 18 s2 := fmt.Sprintf(\"name:%s,age:%d\", name, age) s3 := fmt.Sprintln(\"沙河小王子\") fmt.Println(s1, s2, s3) Errorf Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。 func Errorf(format string, a ...interface{}) error 通常使用这种方式来自定义错误类型，例如： err := fmt.Errorf(\"这是一个错误\") Go1.13版本为fmt.Errorf函数新加了一个%w占位符用来生成一个可以包裹Error的Wrapping Error。 e := errors.New(\"原始错误e\") w := fmt.Errorf(\"Wrap了一个错误%w\", e) ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fmt/:1:1","tags":["Go","fmt"],"title":"Go fmt","uri":"/posts/2023-11-11-go-fmt/"},{"categories":["Go 库文档"],"content":"格式化占位符 *printf系列函数都支持format格式化参数，在这里我们按照占位符将被替换的变量类型划分，方便查询和记忆。 通用占位符 占位符 说明 %v 值的默认格式表示 %+v 类似%v，但输出结构体时会添加字段名 %#v 值的Go语法表示 %T 打印值的类型 %% 百分号 示例代码如下： fmt.Printf(\"%v\\n\", 100) fmt.Printf(\"%v\\n\", false) o := struct{ name string }{\"小王子\"} fmt.Printf(\"%v\\n\", o) fmt.Printf(\"%#v\\n\", o) fmt.Printf(\"%T\\n\", o) fmt.Printf(\"100%%\\n\") 输出结果如下： 100 false {小王子} struct { name string }{name:\"小王子\"} struct { name string } 100% 布尔型 占位符 说明 %t true或false 整型 占位符 说明 %b 表示为二进制 %c 该值对应的unicode码值 %d 表示为十进制 %o 表示为八进制 %x 表示为十六进制，使用a-f %X 表示为十六进制，使用A-F %U 表示为Unicode格式：U+1234，等价于”U+%04X” %q 该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示 示例代码如下： n := 65 fmt.Printf(\"%b\\n\", n) fmt.Printf(\"%c\\n\", n) fmt.Printf(\"%d\\n\", n) fmt.Printf(\"%o\\n\", n) fmt.Printf(\"%x\\n\", n) fmt.Printf(\"%X\\n\", n) 输出结果如下： 1000001 A 65 101 41 41 浮点数与复数 占位符 说明 %b 无小数部分、二进制指数的科学计数法，如-123456p-78 %e 科学计数法，如-1234.456e+78 %E 科学计数法，如-1234.456E+78 %f 有小数部分但无指数部分，如123.456 %F 等价于%f %g 根据实际情况采用%e或%f格式（以获得更简洁、准确的输出） %G 根据实际情况采用%E或%F格式（以获得更简洁、准确的输出） 示例代码如下： f := 12.34 fmt.Printf(\"%b\\n\", f) fmt.Printf(\"%e\\n\", f) fmt.Printf(\"%E\\n\", f) fmt.Printf(\"%f\\n\", f) fmt.Printf(\"%g\\n\", f) fmt.Printf(\"%G\\n\", f) 输出结果如下： 6946802425218990p-49 1.234000e+01 1.234000E+01 12.340000 12.34 12.34 字符串和[]byte 占位符 说明 %s 直接输出字符串或者[]byte %q 该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用a-f %X 每个字节用两字符十六进制数表示（使用A-F） 示例代码如下： s := \"小王子\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%q\\n\", s) fmt.Printf(\"%x\\n\", s) fmt.Printf(\"%X\\n\", s) 输出结果如下： 小王子 \"小王子\" e5b08fe78e8be5ad90 E5B08FE78E8BE5AD90 指针 占位符 说明 %p 表示为十六进制，并加上前导的0x 示例代码如下： a := 10 fmt.Printf(\"%p\\n\", \u0026a) fmt.Printf(\"%#p\\n\", \u0026a) 输出结果如下： 0xc000094000 c000094000 宽度标识符 宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。精度通过（可选的）宽度后跟点号后跟的十进制数指定。如果未指定精度，会使用默认精度；如果点号后没有跟数字，表示精度为0。举例如下： 占位符 说明 %f 默认宽度，默认精度 %9f 宽度9，默认精度 %.2f 默认宽度，精度2 %9.2f 宽度9，精度2 %9.f 宽度9，精度0 示例代码如下： n := 12.34 fmt.Printf(\"%f\\n\", n) fmt.Printf(\"%9f\\n\", n) fmt.Printf(\"%.2f\\n\", n) fmt.Printf(\"%9.2f\\n\", n) fmt.Printf(\"%9.f\\n\", n) 输出结果如下： 12.340000 12.340000 12.34 12.34 12 其他falg 占位符 说明 ’+’ 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格 ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； ’#’ 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）对%q（%#q），对%U（%#U）会输出空格和单引号括起来的go字面值； ‘0’ 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； 举个例子： s := \"小王子\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%5s\\n\", s) fmt.Printf(\"%-5s\\n\", s) fmt.Printf(\"%5.7s\\n\", s) fmt.Printf(\"%-5.7s\\n\", s) fmt.Printf(\"%5.2s\\n\", s) fmt.Printf(\"%05s\\n\", s) 输出结果如下： 小王子 小王子 小王子 小王子 小王子 小王 00小王子 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fmt/:1:2","tags":["Go","fmt"],"title":"Go fmt","uri":"/posts/2023-11-11-go-fmt/"},{"categories":["Go 库文档"],"content":"获取输入 Go语言fmt包下有fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，可以在程序运行过程中从标准输入获取用户的输入。 fmt.Scan 函数定签名如下： func Scan(a ...interface{}) (n int, err error) Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。 具体代码示例如下： func main() { var ( name string age int married bool ) fmt.Scan(\u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔。 $ ./scan_demo 小王子 28 false 扫描结果 name:小王子 age:28 married:false fmt.Scan从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。 fmt.Scanf 函数签名如下： func Scanf(format string, a ...interface{}) (n int, err error) Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。 本函数返回成功扫描的数据个数和遇到的任何错误。 代码示例如下： func main() { var ( name string age int married bool ) fmt.Scanf(\"1:%s 2:%d 3:%t\", \u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端按照指定的格式依次输入小王子、28和false。 $ ./scan_demo 1:小王子 2:28 3:false 扫描结果 name:小王子 age:28 married:false fmt.Scanf不同于fmt.Scan简单的以空格作为输入数据的分隔符，fmt.Scanf为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。 例如，我们还是按照上个示例中以空格分隔的方式输入，fmt.Scanf就不能正确扫描到输入的数据。 $ ./scan_demo 小王子 28 false 扫描结果 name: age:0 married:false fmt.Scanln 函数签名如下： func Scanln(a ...interface{}) (n int, err error) Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。 本函数返回成功扫描的数据个数和遇到的任何错误。 具体代码示例如下： func main() { var ( name string age int married bool ) fmt.Scanln(\u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入小王子、28和false使用空格分隔。 $ ./scan_demo 小王子 28 false 扫描结果 name:小王子 age:28 married:false fmt.Scanln遇到回车就结束扫描了，这个比较常用。 bufio.NewReader 有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下： func bufioDemo() { reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象 fmt.Print(\"请输入内容：\") text, _ := reader.ReadString('\\n') // 读到换行 text = strings.TrimSpace(text) fmt.Printf(\"%#v\\n\", text) } Fscan系列 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。 func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) Sscan系列 这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数据。 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-fmt/:1:3","tags":["Go","fmt"],"title":"Go fmt","uri":"/posts/2023-11-11-go-fmt/"},{"categories":["Go 库文档"],"content":"Go文件操作 参考链接：https://www.liwenzhou.com/posts/Go/go_file/ ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-file/:1:0","tags":["Go","file"],"title":"Go file","uri":"/posts/2023-11-11-go-file/"},{"categories":["Go 库文档"],"content":"文件 计算机中的文件是存储在外部介质（通常是磁盘）上的数据集合，文件分为文本文件和二进制文件 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-file/:1:1","tags":["Go","file"],"title":"Go file","uri":"/posts/2023-11-11-go-file/"},{"categories":["Go 库文档"],"content":"文件打开和关闭 os.Open()函数能够打开一个文件，返回一个*File和一个err。对得到的文件实例调用close()方法能够关闭文件。 package main import ( \"fmt\" \"os\" ) func main() { // 只读方式打开当前目录下的main.go文件 file, err := os.Open(\"./main.go\") if err != nil { fmt.Println(\"open file failed!, err:\", err) return } // 关闭文件 file.Close() } 为了防止文件忘记关闭，我们通常使用defer注册文件关闭语句。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-file/:1:2","tags":["Go","file"],"title":"Go file","uri":"/posts/2023-11-11-go-file/"},{"categories":["Go 库文档"],"content":"读取文件 file.Read() 基本使用 Read方法的定义如下： func (f *File) Read(b []byte) (n int, err error) 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回0和io.EOF。 举个例子： func main() { // 只读方式打开当前目录下的main.go文件 file, err := os.Open(\"./main.go\") if err != nil { fmt.Println(\"open file failed!, err:\", err) return } defer file.Close() // 使用Read方法读取数据 var tmp = make([]byte, 128) n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读完了\") return } if err != nil { fmt.Println(\"read file failed, err:\", err) return } fmt.Printf(\"读取了%d字节数据\\n\", n) fmt.Println(string(tmp[:n])) } 循环读取 使用for循环读取文件中所有的数据 func main() { // 只读方式打开当前目录下的main.go文件 file, err := os.Open(\"./main.go\") if err != nil { fmt.Println(\"open file failed!, err:\", err) return } defer file.Close() // 循环读取文件 var content []byte var tmp = make([]byte, 128) for { n, err := file.Read(tmp) if err == io.EOF { fmt.Println(\"文件读完了\") break } if err != nil { fmt.Println(\"read file failed, err:\", err) return } content = append(content, tmp[:n]...) } fmt.Println(string(content)) } bufio读取文件 bufio是在file的基础上封装了一层API，支持更多的功能。 package main import ( \"bufio\" \"fmt\" \"io\" \"os\" ) // bufio按行读取示例 func main() { file, err := os.Open(\"./xx.txt\") if err != nil { fmt.Println(\"open file failed, err:\", err) return } defer file.Close() reader := bufio.NewReader(file) for { line, err := reader.ReadString('\\n') //注意是字符 if err == io.EOF { if len(line) != 0 { fmt.Println(line) } fmt.Println(\"文件读完了\") break } if err != nil { fmt.Println(\"read file failed, err:\", err) return } fmt.Print(line) } } ioutil读取整个文件 io/ioutil包的ReadFile方法能够读取完整的文件，只需要将文件名作为参数传入。 package main import ( \"fmt\" \"io/ioutil\" ) // ioutil.ReadFile读取整个文件 func main() { content, err := ioutil.ReadFile(\"./main.go\") if err != nil { fmt.Println(\"read file failed, err:\", err) return } fmt.Println(string(content)) } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-file/:1:3","tags":["Go","file"],"title":"Go file","uri":"/posts/2023-11-11-go-file/"},{"categories":["Go 库文档"],"content":"文件写入 os.OpenFile()函数能够以指定模式打开文件，从而实现文件写入相关功能。 func OpenFile(name string, flag int, perm FileMode) (*File, error) { ... } 其中： name：要打开的文件名 flag：打开文件的模式。 模式有以下几种： 模式 含义 os.O_WRONLY 只写 os.O_CREATE 创建文件 os.O_RDONLY 只读 os.O_RDWR 读写 os.O_TRUNC 清空 os.O_APPEND 追加 perm：文件权限，一个八进制数。r（读）4，w（写）2，x（执行）1。 Write和WriteString func main() { file, err := os.OpenFile(\"xx.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file failed, err:\", err) return } defer file.Close() str := \"hello 沙河\" file.Write([]byte(str)) //写入字节切片数据 file.WriteString(\"hello 小王子\") //直接写入字符串数据 } bufio.NewWriter func main() { file, err := os.OpenFile(\"xx.txt\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0666) if err != nil { fmt.Println(\"open file failed, err:\", err) return } defer file.Close() writer := bufio.NewWriter(file) for i := 0; i \u003c 10; i++ { writer.WriteString(\"hello沙河\\n\") //将数据先写入缓存 } writer.Flush() //将缓存中的内容写入文件 } ioutil.WriteFile func main() { str := \"hello 沙河\" err := ioutil.WriteFile(\"./xx.txt\", []byte(str), 0666) if err != nil { fmt.Println(\"write file failed, err:\", err) return } } 练习： 1、实现cp命令 借助io.Copy()实现一个拷贝文件函数。 // CopyFile 拷贝文件函数 func CopyFile(dstName, srcName string) (written int64, err error) { // 以读方式打开源文件 src, err := os.Open(srcName) if err != nil { fmt.Printf(\"open %s failed, err:%v.\\n\", srcName, err) return } defer src.Close() // 以写|创建的方式打开目标文件 dst, err := os.OpenFile(dstName, os.O_WRONLY|os.O_CREATE, 0644) if err != nil { fmt.Printf(\"open %s failed, err:%v.\\n\", dstName, err) return } defer dst.Close() return io.Copy(dst, src) //调用io.Copy()拷贝内容 } func main() { _, err := CopyFile(\"dst.txt\", \"src.txt\") if err != nil { fmt.Println(\"copy file failed, err:\", err) return } fmt.Println(\"copy done!\") } 2、实现cat命令 使用文件操作相关知识，模拟实现linux平台cat命令的功能 package main import ( \"bufio\" \"flag\" \"fmt\" \"io\" \"os\" ) // cat命令实现 func cat(r *bufio.Reader) { for { buf, err := r.ReadBytes('\\n') //注意是字符 if err == io.EOF { // 退出之前将已读到的内容输出 fmt.Fprintf(os.Stdout, \"%s\", buf) break } fmt.Fprintf(os.Stdout, \"%s\", buf) } } func main() { flag.Parse() // 解析命令行参数 if flag.NArg() == 0 { // 如果没有参数默认从标准输入读取内容 cat(bufio.NewReader(os.Stdin)) } // 依次读取每个指定文件的内容并打印到终端 for i := 0; i \u003c flag.NArg(); i++ { f, err := os.Open(flag.Arg(i)) if err != nil { fmt.Fprintf(os.Stdout, \"reading from %s failed, err:%v\\n\", flag.Arg(i), err) continue } cat(bufio.NewReader(f)) } } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-file/:1:4","tags":["Go","file"],"title":"Go file","uri":"/posts/2023-11-11-go-file/"},{"categories":["Go 库文档"],"content":"Excel库excelize 参考链接：[Go 语言读写 Excel - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33417413#:~:text=Excelize 是 Go 语言编写的用于操作 Office Excel 文档类库，基于 ECMA-376,标准。 可以使用它来读取、写入由 Microsoft Excel™ 2007 及以上版本创建的 XLSX 文档。) Excelize 是 Go 语言编写的用于操作 Office Excel 文档类库，基于 ECMA-376 Office OpenXML 标准。可以使用它来读取、写入由 Microsoft Excel™ 2007 及以上版本创建的 XLSX 文档。相比较其他的开源类库，Excelize 支持写入原本带有图片(表)、透视表和切片器等复杂样式的文档，还支持向 Excel 文档中插入图片与图表，并且在保存后不会丢失文档原有样式，可以应用于各类报表系统中。使用本类库要求使用的 Go 语言为 1.8 或更高版本，完整的 API 使用文档请访问 godoc.org 或查看参考文档。 GitHub: excelize 官方文档：https://xuri.me/excelize ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-excelize/:1:0","tags":["Go","excelize","xls","xlsx"],"title":"Go excelize","uri":"/posts/2023-11-11-go-excelize/"},{"categories":["Go 库文档"],"content":"1、简单使用 安装 go get github.com/xuri/excelize/v2 1）创建XLSX package main import \"github.com/360EntSecGroup-Skylar/excelize\" func main() { f := excelize.NewFile() // 创建一个工作表 index := f.NewSheet(\"Sheet2\") // 设置单元格的值 f.SetCellValue(\"Sheet1\", \"A2\", \"Hello world.\") f.SetCellValue(\"Sheet1\", \"B2\", 100) f.SetCellValue(\"Sheet1\", \"B3\", \"github\") // 设置工作簿的默认工作表 f.SetActiveSheet(index) // 根据指定路径保存文件 if err := f.SaveAs(\"Book1.xlsx\"); err != nil { println(err.Error()) } } 结果： SetCellValue函数解释 f.SetCellValue(sheet string, axis string, value interface{}) f.SetCellValue(\"Sheet1\", \"B3\", \"github\") sheet：是sheet表格的的名字。 axis：包含两部分，字母表示列，数字表示行。 value：表示值。 2）读取xlsx func ReadXlsx() { filename := \"Book1.xlsx\" f, err := excelize.OpenFile(filename) if err != nil { fmt.Printf(\"无法打开xlsx：%v 错误原因：%v\", filename, err) return } // 获取工作表中指定单元格的值 cell, err := f.GetCellValue(\"Sheet1\", \"B3\") if err != nil { fmt.Printf(\"获取 %v 的%v的 值 失败,失败原因：%v\", \"Sheet1\", \"B3\", err) } fmt.Printf(\"读取的内容为：%v\", cell) // 获取 Sheet1 上所有单元格 rows, err := f.GetRows(\"Sheet1\") if err != nil { fmt.Printf(\"获取 %v的单元格失败,失败原因：%v\", \"Sheet1\", err) } for _, row := range rows { for _, colCell := range row { print(colCell, \"\\t\") } println() } } 3）插入一行数据 func (exa *ExcelService) ParseInfoList2Excel(infoList []system.SysBaseMenu, filePath string) error { excel := excelize.NewFile() excel.SetSheetRow(\"Sheet1\", \"A1\", \u0026[]string{\"ID\", \"路由Name\", \"路由Path\", \"是否隐藏\", \"父节点\", \"排序\", \"文件名称\"}) for i, menu := range infoList { axis := fmt.Sprintf(\"A%d\", i+2) excel.SetSheetRow(\"Sheet1\", axis, \u0026[]interface{}{ menu.ID, menu.Name, menu.Path, menu.Hidden, menu.ParentId, menu.Sort, menu.Component, }) } err := excel.SaveAs(filePath) return err } 4）从表格中导入数据 func PasreExcel2List(filepath string, fileHeader []string, skipHeader bool) (data [][]string, err error) { file, err := excelize.OpenFile(filepath) if err != nil { return } defer file.Close() rows, err := file.GetRows(\"Sheet1\") if err != nil { return } if skipHeader { if ForEqualStringSlice(rows[0], fileHeader) { rows = rows[1:] } else { err = errors.New(\"FileHeader not Equal.\") return } } data = rows return } func (exa *ExcelService) ParseExcel2InfoList() ([]system.SysBaseMenu, error) { skipHeader := true fixedHeader := []string{\"ID\", \"路由Name\", \"路由Path\", \"是否隐藏\", \"父节点\", \"排序\", \"文件名称\"} file, err := excelize.OpenFile(global.GVA_CONFIG.Excel.Dir + \"ExcelImport.xlsx\") if err != nil { return nil, err } menus := make([]system.SysBaseMenu, 0) rows, err := file.Rows(\"Sheet1\") if err != nil { return nil, err } for rows.Next() { row, err := rows.Columns() if err != nil { return nil, err } if skipHeader { if exa.compareStrSlice(row, fixedHeader) { skipHeader = false continue } else { return nil, errors.New(\"Excel格式错误\") } } if len(row) != len(fixedHeader) { continue } id, _ := strconv.Atoi(row[0]) hidden, _ := strconv.ParseBool(row[3]) sort, _ := strconv.Atoi(row[5]) menu := system.SysBaseMenu{ GVA_MODEL: global.GVA_MODEL{ ID: uint(id), }, Name: row[1], Path: row[2], Hidden: hidden, ParentId: row[4], Sort: sort, Component: row[6], } menus = append(menus, menu) } return menus, nil } func (exa *ExcelService) compareStrSlice(a, b []string) bool { if len(a) != len(b) { return false } if (b == nil) != (a == nil) { return false } for key, value := range a { if value != b[key] { return false } } return true } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-excelize/:1:1","tags":["Go","excelize","xls","xlsx"],"title":"Go excelize","uri":"/posts/2023-11-11-go-excelize/"},{"categories":["Go 库文档"],"content":"cron定时任务 参考链接：https://segmentfault.com/a/1190000023029219 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:0","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"简介 cron一个用于管理定时任务的库，用 Go 实现 Linux 中crontab这个命令的效果。之前我们也介绍过一个类似的 Go 库——gron。gron代码小巧，用于学习是比较好的。但是它功能相对简单些，并且已经不维护了。如果有定时任务需求，还是建议使用cron。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:1","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"快速使用 安装cron，目前最新稳定版本为 v3： $ go get github.com/robfig/cron/v3 使用 package main import ( \"fmt\" \"time\" \"github.com/robfig/cron/v3\" ) func main() { c := cron.New() c.AddFunc(\"@every 1s\", func() { fmt.Println(\"tick every 1 second\") }) c.Start() time.Sleep(time.Second * 5) } 使用非常简单，创建cron对象，这个对象用于管理定时任务。 调用cron对象的AddFunc()方法向管理器中添加定时任务。AddFunc()接受两个参数，参数 1 以字符串形式指定触发时间规则，参数 2 是一个无参的函数，每次触发时调用。@every 1s表示每秒触发一次，@every后加一个时间间隔，表示每隔多长时间触发一次。例如@every 1h表示每小时触发一次，@every 1m2s表示每隔 1 分 2 秒触发一次。time.ParseDuration()支持的格式都可以用在这里。 调用c.Start()启动定时循环。 注意一点，因为c.Start()启动一个新的 goroutine 做循环检测，我们在代码最后加了一行time.Sleep(time.Second * 5)防止主 goroutine 退出。 运行效果，每隔 1s 输出一行字符串： $ go run main.go tick every 1 second tick every 1 second tick every 1 second tick every 1 second tick every 1 second ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:2","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"时间格式 与Linux 中crontab命令相似，cron库支持用 5 个空格分隔的域来表示时间。这 5 个域含义依次为： Minutes：分钟，取值范围[0-59]，支持特殊字符* / , -； Hours：小时，取值范围[0-23]，支持特殊字符* / , -； Day of month：每月的第几天，取值范围[1-31]，支持特殊字符* / , - ?； Month：月，取值范围[1-12]或者使用月份名字缩写[JAN-DEC]，支持特殊字符* / , -； Day of week：周历，取值范围[0-6]或名字缩写[JUN-SAT]，支持特殊字符* / , - ?。 注意，月份和周历名称都是不区分大小写的，也就是说SUN/Sun/sun表示同样的含义（都是周日）。 特殊字符含义如下： *：使用*的域可以匹配任何值，例如将月份域（第 4 个）设置为*，表示每个月； /：用来指定范围的步长，例如将小时域（第 2 个）设置为3-59/15表示第 3 分钟触发，以后每隔 15 分钟触发一次，因此第 2 次触发为第 18 分钟，第 3 次为 33 分钟。。。直到分钟大于 59； ,：用来列举一些离散的值和多个范围，例如将周历的域（第 5 个）设置为MON,WED,FRI表示周一、三和五； -：用来表示范围，例如将小时的域（第 1 个）设置为9-17表示上午 9 点到下午 17 点（包括 9 和 17）； ?：只能用在月历和周历的域中，用来代替*，表示每月/周的任意一天。 了解规则之后，我们可以定义任意时间： 30 * * * *：分钟域为 30，其他域都是*表示任意。每小时的 30 分触发； 30 3-6,20-23 * * *：分钟域为 30，小时域的3-6,20-23表示 3 点到 6 点和 20 点到 23 点。3,4,5,6,20,21,22,23 时的 30 分触发； 0 0 1 1 *：1（第 4 个） 月 1（第 3 个） 号的 0（第 2 个） 时 0（第 1 个） 分触发。 记熟了这几个域的顺序，再多练习几次很容易就能掌握格式。熟悉规则了之后，就能熟练使用crontab命令了。 func main() { c := cron.New() c.AddFunc(\"30 * * * *\", func() { fmt.Println(\"Every hour on the half hour\") }) c.AddFunc(\"30 3-6,20-23 * * *\", func() { fmt.Println(\"On the half hour of 3-6am, 8-11pm\") }) c.AddFunc(\"0 0 1 1 *\", func() { fmt.Println(\"Jun 1 every year\") }) c.Start() for { time.Sleep(time.Second) } } 预定义时间规则 为了方便使用，cron预定义了一些时间规则： @yearly：也可以写作@annually，表示每年第一天的 0 点。等价于0 0 1 1 *； @monthly：表示每月第一天的 0 点。等价于0 0 1 * *； @weekly：表示每周第一天的 0 点，注意第一天为周日，即周六结束，周日开始的那个 0 点。等价于0 0 * * 0； @daily：也可以写作@midnight，表示每天 0 点。等价于0 0 * * *； @hourly：表示每小时的开始。等价于0 * * * *。 例如： func main() { c := cron.New() c.AddFunc(\"@hourly\", func() { fmt.Println(\"Every hour\") }) c.AddFunc(\"@daily\", func() { fmt.Println(\"Every day on midnight\") }) c.AddFunc(\"@weekly\", func() { fmt.Println(\"Every week\") }) c.Start() for { time.Sleep(time.Second) } } 上面代码只是演示用法，实际运行可能要等待非常长的时间才能有输出。 固定时间间隔 cron支持固定时间间隔，格式为： @every \u003cduration\u003e 含义为每隔duration触发一次。``会调用time.ParseDuration()函数解析，所以ParseDuration支持的格式都可以。例如1h30m10s。在快速开始部分，我们已经演示了@every的用法了，这里就不赘述了。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:3","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"时区 默认情况下，所有时间都是基于当前时区的。当然我们也可以指定时区，有 2 两种方式： 在时间字符串前面添加一个CRON_TZ= + 具体时区，具体时区的格式在之前carbon的文章中有详细介绍。东京时区为Asia/Tokyo，纽约时区为America/New_York； 创建cron对象时增加一个时区选项cron.WithLocation(location)，location为time.LoadLocation(zone)加载的时区对象，zone为具体的时区格式。或者调用已创建好的cron对象的SetLocation()方法设置时区。 示例： func main() { nyc, _ := time.LoadLocation(\"America/New_York\") c := cron.New(cron.WithLocation(nyc)) c.AddFunc(\"0 6 * * ?\", func() { fmt.Println(\"Every 6 o'clock at New York\") }) c.AddFunc(\"CRON_TZ=Asia/Tokyo 0 6 * * ?\", func() { fmt.Println(\"Every 6 o'clock at Tokyo\") }) c.Start() for { time.Sleep(time.Second) } } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:4","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"Job接口 除了直接将无参函数作为回调外，cron还支持Job接口： // cron.go type Job interface { Run() } 我们定义一个实现接口Job的结构： type GreetingJob struct { Name string } func (g GreetingJob) Run() { fmt.Println(\"Hello \", g.Name) } 调用cron对象的AddJob()方法将GreetingJob对象添加到定时管理器中： func main() { c := cron.New() c.AddJob(\"@every 1s\", GreetingJob{\"dj\"}) c.Start() time.Sleep(5 * time.Second) } 运行效果： $ go run main.go Hello dj Hello dj Hello dj Hello dj Hello dj 使用自定义的结构可以让任务携带状态（Name字段）。 实际上AddFunc()方法内部也调用了AddJob()方法。首先，cron基于func()类型定义一个新的类型FuncJob： // cron.go type FuncJob func() 然后让FuncJob实现Job接口： // cron.go func (f FuncJob) Run() { f() } 在AddFunc()方法中，将传入的回调转为FuncJob类型，然后调用AddJob()方法： func (c *Cron) AddFunc(spec string, cmd func()) (EntryID, error) { return c.AddJob(spec, FuncJob(cmd)) } ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:5","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"线程安全 cron会创建一个新的 goroutine 来执行触发回调。如果这些回调需要并发访问一些资源、数据，我们需要显式地做同步。 ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:6","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"自定义时间格式 cron支持灵活的时间格式，如果默认的格式不能满足要求，我们可以自己定义时间格式。时间规则字符串需要cron.Parser对象来解析。我们先来看看默认的解析器是如何工作的。 首先定义各个域： // parser.go const ( Second ParseOption = 1 \u003c\u003c iota SecondOptional Minute Hour Dom Month Dow DowOptional Descriptor ) 除了Minute/Hour/Dom(Day of month)/Month/Dow(Day of week)外，还可以支持Second。相对顺序都是固定的： // parser.go var places = []ParseOption{ Second, Minute, Hour, Dom, Month, Dow, } var defaults = []string{ \"0\", \"0\", \"0\", \"*\", \"*\", \"*\", } 默认的时间格式使用 5 个域。 我们可以调用cron.NewParser()创建自己的Parser对象，以位格式传入使用哪些域，例如下面的Parser使用 6 个域，支持Second（秒）： parser := cron.NewParser( cron.Second | cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow | cron.Descriptor, ) 调用cron.WithParser(parser)创建一个选项传入构造函数cron.New()，使用时就可以指定秒了： c := cron.New(cron.WithParser(parser)) c.AddFunc(\"1 * * * * *\", func () { fmt.Println(\"every 1 second\") }) c.Start() 这里时间格式必须使用 6 个域，顺序与上面的const定义一致。 因为上面的时间格式太常见了，cron定义了一个便捷的函数： // option.go func WithSeconds() Option { return WithParser(NewParser( Second | Minute | Hour | Dom | Month | Dow | Descriptor, )) } 注意Descriptor表示对@every/@hour等的支持。有了WithSeconds()，我们不用手动创建Parser对象了： c := cron.New(cron.WithSeconds()) ","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:7","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"选项 cron对象创建使用了选项模式，我们前面已经介绍了 3 个选项： WithLocation：指定时区； WithParser：使用自定义的解析器； WithSeconds：让时间格式支持秒，实际上内部调用了WithParser。 cron还提供了另外两种选项： WithLogger：自定义Logger； WithChain：Job 包装器。 WithLogger WithLogger可以设置cron内部使用我们自定义的Logger： func main() { c := cron.New( cron.WithLogger( cron.VerbosePrintfLogger(log.New(os.Stdout, \"cron: \", log.LstdFlags)))) c.AddFunc(\"@every 1s\", func() { fmt.Println(\"hello world\") }) c.Start() time.Sleep(5 * time.Second) } 上面调用cron.VerbosPrintfLogger()包装log.Logger，这个logger会详细记录cron内部的调度过程： $ go run main.go cron: 2020/06/26 07:09:14 start cron: 2020/06/26 07:09:14 schedule, now=2020-06-26T07:09:14+08:00, entry=1, next=2020-06-26T07:09:15+08:00 cron: 2020/06/26 07:09:15 wake, now=2020-06-26T07:09:15+08:00 cron: 2020/06/26 07:09:15 run, now=2020-06-26T07:09:15+08:00, entry=1, next=2020-06-26T07:09:16+08:00 hello world cron: 2020/06/26 07:09:16 wake, now=2020-06-26T07:09:16+08:00 cron: 2020/06/26 07:09:16 run, now=2020-06-26T07:09:16+08:00, entry=1, next=2020-06-26T07:09:17+08:00 hello world cron: 2020/06/26 07:09:17 wake, now=2020-06-26T07:09:17+08:00 cron: 2020/06/26 07:09:17 run, now=2020-06-26T07:09:17+08:00, entry=1, next=2020-06-26T07:09:18+08:00 hello world cron: 2020/06/26 07:09:18 wake, now=2020-06-26T07:09:18+08:00 hello world cron: 2020/06/26 07:09:18 run, now=2020-06-26T07:09:18+08:00, entry=1, next=2020-06-26T07:09:19+08:00 cron: 2020/06/26 07:09:19 wake, now=2020-06-26T07:09:19+08:00 hello world cron: 2020/06/26 07:09:19 run, now=2020-06-26T07:09:19+08:00, entry=1, next=2020-06-26T07:09:20+08:0 我们看看默认的Logger是什么样的： // logger.go var DefaultLogger Logger = PrintfLogger(log.New(os.Stdout, \"cron: \", log.LstdFlags)) func PrintfLogger(l interface{ Printf(string, ...interface{}) }) Logger { return printfLogger{l, false} } func VerbosePrintfLogger(l interface{ Printf(string, ...interface{}) }) Logger { return printfLogger{l, true} } type printfLogger struct { logger interface{ Printf(string, ...interface{}) } logInfo bool } WithChain Job 包装器可以在执行实际的Job前后添加一些逻辑： 捕获panic； 如果Job上次运行还未结束，推迟本次执行; 如果Job上次运行还未介绍，跳过本次执行； 记录每个Job的执行情况。 我们可以将Chain类比为 Web 处理器的中间件。实际上就是在Job的执行逻辑外在封装一层逻辑。我们的封装逻辑需要写成一个函数，传入一个Job类型，返回封装后的Job。cron为这种函数定义了一个类型JobWrapper： // chain.go type JobWrapper func(Job) Job 然后使用一个Chain对象将这些JobWrapper组合到一起： type Chain struct { wrappers []JobWrapper } func NewChain(c ...JobWrapper) Chain { return Chain{c} } 调用Chain对象的Then(job)方法应用这些JobWrapper，返回最终的`Job： func (c Chain) Then(j Job) Job { for i := range c.wrappers { j = c.wrappers[len(c.wrappers)-i-1](j) } return j } 注意应用JobWrapper的顺序。 内置JobWrapper cron内置了 3 个用得比较多的JobWrapper： Recover：捕获内部Job产生的 panic； DelayIfStillRunning：触发时，如果上一次任务还未执行完成（耗时太长），则等待上一次任务完成之后再执行； SkipIfStillRunning：触发时，如果上一次任务还未完成，则跳过此次执行。 下面分别介绍。 Recover 先看看如何使用： type panicJob struct { count int } func (p *panicJob) Run() { p.count++ if p.count == 1 { panic(\"oooooooooooooops!!!\") } fmt.Println(\"hello world\") } func main() { c := cron.New() c.AddJob(\"@every 1s\", cron.NewChain(cron.Recover(cron.DefaultLogger)).Then(\u0026panicJob{})) c.Start() time.Sleep(5 * time.Second) } panicJob在第一次触发时，触发了panic。因为有cron.Recover()保护，后续任务还能执行： go run main.go cron: 2020/06/27 14:02:00 panic, error=oooooooooooooops!!!, stack=... goroutine 18 [running]: github.com/robfig/cron/v3.Recover.func1.1.1(0x514ee0, 0xc0000044a0) D:/code/golang/pkg/mod/github.com/robfig/cron/v3@v3.0.1/chain.go:45 +0xbc panic(0x4cf380, 0x513280) C:/Go/src/runtime/panic.go:969 +0x174 main.(*panicJob).Run(0xc0000140e8) D:/code/golang/src/github.com/darjun/go-daily-lib/cron/recover/main.go:17 +0xba github.com/robfig/cron/v3.Recover.func1.1() D:/code/golang/pkg/mod/github.com/robfig/cron/v3@v3.0.1/chain.go:53 +0x6f github.com/robfig/cron/v3.FuncJob.Run(0xc000070390) D:/code/golang/pkg/mod/github.com/robfig/cron/v3@v3.0.1/cron.go:136 +0x2c github.com/robfig/cron/v3.(*Cron).startJob.func1(0xc00005c0a0, 0x514d20, 0xc000070390) D:/code/golang/pkg/mod/github.com/robfig/cron/v3@v3.0.1/cron.go:312 +0x68 created by github.com/robfig/cron/v3.(*Cron).startJob D:","date":"2023-11-11","objectID":"/posts/2023-11-11-go-cron/:1:8","tags":["Go","cron"],"title":"Go cron","uri":"/posts/2023-11-11-go-cron/"},{"categories":["Go 库文档"],"content":"Go goph库 链接地址： github.com/melbahja/goph github.com/serialt/goph (方便指定端口) ","date":"2023-11-10","objectID":"/posts/go-goth/:0:0","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"特性 易于使用，简化 ssh api。 支持ssh 密码、私钥，带密码的私钥。 支持从本地上传文件和从远程下载文件。 支持 ssh 使用 ssh-agent 连接会话。 支持增加主机到 known_hosts 文件。 ","date":"2023-11-10","objectID":"/posts/go-goth/:1:0","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"安装 go get github.com/serialt/goph ","date":"2023-11-10","objectID":"/posts/go-goth/:2:0","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"使用示例 ","date":"2023-11-10","objectID":"/posts/go-goth/:3:0","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"1、使用执行命令 package main import ( \"fmt\" \"log\" \"github.com/serialt/goph\" ) var Client *goph.Client func init() { auth, err := goph.Key(os.Getenv(\"HOME\")+\"/.ssh/id_rsa\", \"\") if err != nil { log.Fatalf(\"cat read the ssh private key: %v\", err) } client, err := goph.New(\"root\", \"10.10.16.10\", 22, auth) if err != nil { log.Fatalf(\"ssh link faild: %v\", err) } Client = client } func main() { result, err := Client.Run(\"date\") fmt.Printf(\"result: %v\\nerr: %v\", string(result), err) defer Client.Close() } ","date":"2023-11-10","objectID":"/posts/go-goth/:3:1","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"2、从字符串中读取私钥 package main import ( \"fmt\" \"log\" \"github.com/serialt/goph\" ) var Client *goph.Client var sshkey = ` -----BEGIN OPENSSH PRIVATE KEY----- NeY6rItzuvwtiPa5etNiAAAAGnNlcmlhbHQgdHNlcmlhbHRAZ21haWwuY29tAQID NeY6rItzuvwtiPa5etNiAAAAGnNlcmlhbHQgdHNlcmlhbHRAZ21haWwuY29tAQID NeY6rItzuvwtiPa5etNiAAAAGnNlcmlhbHQgdHNlcmlhbHRAZ21haWwuY29tAQID AAAECptYaTKFA2Omsb67+FN2SPr3daBAA0IxpVwv5KYJ1QKWR98JYVP7/WAqffRO NeY6rItzuvwtiPa5etNiAAAAGnNlcmlhbHQgdHNlcmlhbHRAZ21haWwuY29tAQID -----END OPENSSH PRIVATE KEY----- ` func init() { auth, err := goph.RawKey(sshkey, \"\") if err != nil { log.Fatalf(\"cat read the ssh private key: %v\", err) } client, err := goph.New(\"root\", \"10.10.16.10\", 22, auth) if err != nil { log.Fatalf(\"ssh link faild: %v\", err) } Client = client } func main() { result, err := Client.Run(\"date\") fmt.Printf(\"result: %v\\nerr: %v\", string(result), err) defer Client.Close() } ","date":"2023-11-10","objectID":"/posts/go-goth/:3:2","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"3、密钥带密码 auth, err := goph.Key(os.Getenv(\"HOME\")+\"/.ssh/id_rsa\", \"you_passphrase_here\") if err != nil { // handle error } client, err := goph.New(\"root\", \"192.1.1.3\", auth) ","date":"2023-11-10","objectID":"/posts/go-goth/:3:3","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"4、使用密码 auth, err := goph.UseAgent() if err != nil { // handle error } client, err := goph.New(\"root\", \"192.1.1.1\", auth) ","date":"2023-11-10","objectID":"/posts/go-goth/:3:4","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"5、上传和下载文件 // upload local file to remote err := client.Upload(\"/path/to/local/file\", \"/path/to/remote/file\") // download remote file to local err := client.Download(\"/path/to/remote/file\", \"/path/to/local/file\") ","date":"2023-11-10","objectID":"/posts/go-goth/:3:5","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"6、执行shell命令 // execute bash commands out, err := client.Run(\"bash -c 'printenv'\") // execute bash command whith timeout context, cancel := context.WithTimeout(ctx, time.Second) defer cancel() // will send SIGINT and return error after 1 second out, err := client.RunContext(ctx, \"sleep 5\") // execute bash command whith env variables out, err := client.Run(`env MYVAR=\"MY VALUE\" bash -c 'echo $MYVAR;'`) ","date":"2023-11-10","objectID":"/posts/go-goth/:3:6","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"7、使用goph cmd Goph.Cmd struct is like the Go standard os/exec.Cmd. // Get new `Goph.Cmd` cmd, err := client.Command(\"ls\", \"-alh\", \"/tmp\") // or with context: // cmd, err := client.CommandContext(ctx, \"ls\", \"-alh\", \"/tmp\") if err != nil { // handle the error! } // You can set env vars, but the server must be configured to `AcceptEnv line`. cmd.Env = []string{\"MY_VAR=MYVALUE\"} // Run you command. err = cmd.Run() ust like os/exec.Cmd you can run CombinedOutput, Output, Start, Wait, and ssh.Session methods like Signal… ","date":"2023-11-10","objectID":"/posts/go-goth/:3:7","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"8、使用sftp操作文件系统 sftp, err := client.NewSftp() if err != nil { // handle the error! } file, err := sftp.Create(\"/tmp/remote_file\") file.Write([]byte(`Hello world`)) file.Close() For more file operations see SFTP Docs. ","date":"2023-11-10","objectID":"/posts/go-goth/:3:8","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["Go 库文档"],"content":"官方示例 package main import ( \"bufio\" \"context\" \"errors\" \"flag\" \"fmt\" \"log\" \"net\" \"os\" osuser \"os/user\" \"path/filepath\" \"strings\" \"time\" \"github.com/pkg/sftp\" \"github.com/serialt/goph\" \"golang.org/x/crypto/ssh\" \"golang.org/x/crypto/ssh/terminal\" ) // // Run command and auth via password: // \u003e go run main.go --ip 192.168.122.102 --pass --cmd ls // // Run command and auth via private key: // \u003e go run main.go --ip 192.168.122.102 --cmd ls // Or: // \u003e go run main.go --ip 192.168.122.102 --key /path/to/private_key --cmd ls // // Run command and auth with private key and passphrase: // \u003e go run main.go --ip 192.168.122.102 --passphrase --cmd ls // // Run a command and interrupt it after 1 second: // \u003e go run main.go --ip 192.168.122.102 --cmd \"sleep 10\" --timeout=1s // // You can test with the interactive mode without passing --cmd flag. // var ( err error auth goph.Auth client *goph.Client addr string user string port uint key string cmd string pass bool passphrase bool timeout time.Duration agent bool sftpc *sftp.Client ) func init() { usr, err := osuser.Current() if err != nil { fmt.Println(\"couldn't determine current user. defaulting to 'root'\") usr.Username = \"root\" } flag.StringVar(\u0026addr, \"ip\", \"127.0.0.1\", \"machine ip address.\") flag.StringVar(\u0026user, \"user\", usr.Username, \"ssh user.\") flag.UintVar(\u0026port, \"port\", 22, \"ssh port number.\") flag.StringVar(\u0026key, \"key\", filepath.Join(os.Getenv(\"HOME\"), \".ssh\", \"id_rsa\"), \"private key path.\") flag.StringVar(\u0026cmd, \"cmd\", \"\", \"command to run.\") flag.BoolVar(\u0026pass, \"pass\", false, \"ask for ssh password instead of private key.\") flag.BoolVar(\u0026agent, \"agent\", false, \"use ssh agent for authentication (unix systems only).\") flag.BoolVar(\u0026passphrase, \"passphrase\", false, \"ask for private key passphrase.\") flag.DurationVar(\u0026timeout, \"timeout\", 0, \"interrupt a command with SIGINT after a given timeout (0 means no timeout)\") } func VerifyHost(host string, remote net.Addr, key ssh.PublicKey) error { // // If you want to connect to new hosts. // here your should check new connections public keys // if the key not trusted you shuld return an error // // hostFound: is host in known hosts file. // err: error if key not in known hosts file OR host in known hosts file but key changed! hostFound, err := goph.CheckKnownHost(host, remote, key, \"\") // Host in known hosts but key mismatch! // Maybe because of MAN IN THE MIDDLE ATTACK! if hostFound \u0026\u0026 err != nil { return err } // handshake because public key already exists. if hostFound \u0026\u0026 err == nil { return nil } // Ask user to check if he trust the host public key. if askIsHostTrusted(host, key) == false { // Make sure to return error on non trusted keys. return errors.New(\"you typed no, aborted!\") } // Add the new host to known hosts file. return goph.AddKnownHost(host, remote, key, \"\") } func main() { flag.Parse() var err error if agent || goph.HasAgent() { auth, err = goph.UseAgent() } else if pass { auth = goph.Password(askPass(\"Enter SSH Password: \")) } else { auth, err = goph.Key(key, getPassphrase(passphrase)) } if err != nil { panic(err) } client, err = goph.NewConn(\u0026goph.Config{ User: user, Addr: addr, Port: port, Auth: auth, Callback: VerifyHost, }) if err != nil { panic(err) } // Close client net connection defer client.Close() // If the cmd flag exists if cmd != \"\" { ctx := context.Background() // create a context with timeout, if supplied in the argumetns if timeout \u003e 0 { var cancel context.CancelFunc ctx, cancel = context.WithTimeout(ctx, timeout) defer cancel() } out, err := client.RunContext(ctx, cmd) fmt.Println(string(out), err) return } // else open interactive mode. playWithSSHJustForTestingThisProgram(client) } func askPass(msg string) string { fmt.Print(msg) pass, err := terminal.ReadPassword(0) if err != nil { panic(err) } fmt.Println(\"\") return strings.TrimSpace(string(pass)) } func getPassphrase(ask bool) string { if ask { return askPass(\"Enter Private Key Passphrase: \") } return \"\" } func askIsHostTrusted(host string, key ssh.Public","date":"2023-11-10","objectID":"/posts/go-goth/:4:0","tags":["Go","goph","ssh","sftp"],"title":"Go goph","uri":"/posts/go-goth/"},{"categories":["同步oci镜像"],"content":"镜像同步 参考链接： https://lework.github.io/2020/04/13/skopeo/ https://blog.k8s.li/skopeo.html 日常工作中，需要将各种镜像搬到对应的仓库中，docker 适合于构建镜像，将镜像推送于仓库中。镜像被推送到仓库中后，如果需要对镜像进行搬运，在仓库不提供这个功能的情况下，同步镜像是比较困难的。 skopeo 是红帽开源的容器镜像管理工具。相比于docker，它有一下的优点： 支持多个平台：skopeo 支持 Linux，Mac 和 Windows。 无需 docker 或者 podman：skopeo 可以构建为单一的 cli，不依赖于 docker 服务或者 podman。 支持多个 OCI 镜像仓库间同步：支持 OCI 的镜像托管服务，都可以相互同步。 支持多架构镜像同步：可以同步多种架构的镜像。 镜像验签：skopeo 支持镜像签名，可确保镜像的完整性和可靠性。 ","date":"2023-11-08","objectID":"/posts/skopeo/:0:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"一、编译skopeo skopeo 官方并不提供编译好的静态二进制可执行文件，常见的系统源中已经包含了 skopeo，但由于 skopeo 的版本迭代比较快，新的功能也随之增加，部分操作系统里提供的安装包版本可能比较低，无法适用，且 skopeo 大多都是链接了动态库，无法通用于多个 linux 发行版，因此可以借助docker实现skopeo的静态编译。 基于github action构建skopeo: skopeo ","date":"2023-11-08","objectID":"/posts/skopeo/:1:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"下载 skopeo 源码 # download source code git clone --depth=1 https://github.com/containers/skopeo.git ","date":"2023-11-08","objectID":"/posts/skopeo/:1:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建build镜像的Dockerfile 国内构建则需要修改 alpine 和 go 镜像地址，可直连 github 的可以忽略此步 FROM golang:1.19-alpine3.16 AS builder ENV LANG=C.UTF-8 ENV TZ=Asia/Shanghai ENV CGO_ENABLED=0 ENV GOPROXY=https://goproxy.cn,direct RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories RUN apk update --no-cache \u0026\u0026 apk add --no-cache ca-certificates ","date":"2023-11-08","objectID":"/posts/skopeo/:1:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建 build 镜像 docker build -t skopeo-build . ","date":"2023-11-08","objectID":"/posts/skopeo/:1:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建 skopeo 静态二进制可执行文件 cd skopeo/ # 构建 linux amd64 架构 docker run --rm -t -v $PWD:/build skopeo-build sh -c \"apk update \u0026\u0026 apk add gpgme btrfs-progs-dev llvm13-dev gcc musl-dev \u0026\u0026 cd /build \u0026\u0026 CGO_ENABLE=0 GO111MODULE=on GOOS=linux GOARCH=amd64 go build -mod=vendor '-buildmode=pie' -ldflags '-extldflags -static' -gcflags '' -tags 'exclude_graphdriver_devicemapper exclude_graphdriver_btrfs containers_image_openpgp' -o ./bin/skopeo-linux-amd64 ./cmd/skopeo \" # 构建 linux arm64 架构 docker run --rm -t -v $PWD:/build skopeo-build sh -c \"apk update \u0026\u0026 apk add gpgme btrfs-progs-dev llvm13-dev gcc musl-dev \u0026\u0026 cd /build \u0026\u0026 CGO_ENABLE=0 GO111MODULE=on GOOS=linux GOARCH=arm64 go build -mod=vendor '-buildmode=pie' -ldflags '-extldflags -static' -gcflags '' -tags 'exclude_graphdriver_devicemapper exclude_graphdriver_btrfs containers_image_openpgp' -o ./bin/skopeo-linux-arm64 ./cmd/skopeo \" ","date":"2023-11-08","objectID":"/posts/skopeo/:1:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"二、skopeo 命令使用 [root@tc ~]# skopeo -v skopeo version 1.11.1-dev [root@tc ~]# skopeo --help Various operations with container images and container image registries Usage: skopeo [flags] skopeo [command] Available Commands: copy Copy an IMAGE-NAME from one location to another delete Delete image IMAGE-NAME generate-sigstore-key Generate a sigstore public/private key pair help Help about any command inspect Inspect image IMAGE-NAME list-tags List tags in the transport/repository specified by the SOURCE-IMAGE login Login to a container registry logout Logout of a container registry manifest-digest Compute a manifest digest of a file standalone-sign Create a signature using local files standalone-verify Verify a signature using local files sync Synchronize one or more images from one location to another Flags: --command-timeout duration timeout for the command execution --debug enable debug output -h, --help help for skopeo --insecure-policy run the tool without any policy check --override-arch ARCH use ARCH instead of the architecture of the machine for choosing images --override-os OS use OS instead of the running OS for choosing images --override-variant VARIANT use VARIANT instead of the running architecture variant for choosing images --policy string Path to a trust policy file --registries.d DIR use registry configuration files in DIR (e.g. for container signature storage) --tmpdir string directory used to store temporary files -v, --version Version for Skopeo Use \"skopeo [command] --help\" for more information about a command. # 登录与登出 oci skopeo login -u username docker.io skopeo logout docker.io 不下载镜像情况下获取镜像信息 [root@tc ~]# skopeo inspect docker://docker.io/alpine { \"Name\": \"docker.io/library/alpine\", \"Digest\": \"sha256:eece025e432126ce23f223450a0326fbebde39cdf496a85d8c016293fc851978\", \"RepoTags\": [ \"20220316\", \"20220328\", \"20220715\", \"20221110\", \"20230208\", \"20230329\", \"20230901\", \"3\", \"3.17\", \"3.17.0\", \"3.17.0_rc1\", \"3.17.1\", \"3.17.2\", \"3.17.3\", \"3.17.4\", \"3.17.5\", \"3.18\", \"3.18.0\", \"3.18.2\", \"3.18.3\", \"3.18.4\", \"edge\", \"latest\" ], \"Created\": \"2023-09-28T21:19:27.801479409Z\", \"DockerVersion\": \"20.10.23\", \"Labels\": null, \"Architecture\": \"amd64\", \"Os\": \"linux\", \"Layers\": [ \"sha256:96526aa774ef0126ad0fe9e9a95764c5fc37f409ab9e97021e7b4775d82bf6fa\" ], \"LayersData\": [ { \"MIMEType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"Digest\": \"sha256:96526aa774ef0126ad0fe9e9a95764c5fc37f409ab9e97021e7b4775d82bf6fa\", \"Size\": 3401967, \"Annotations\": null } ], \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } docker://: 是使用 Docker Registry HTTP API V2 进行连接远端 docker.io: 远程仓库 alpine: 镜像名称 获取本地镜像信息 [root@tc ~]# skopeo inspect docker-daemon:alpine:3 { \"Name\": \"docker.io/library/alpine\", \"Digest\": \"sha256:844bc35fdf7a96e5b6bf5e76e20989a797cc75976fad73275061a36f448b92b9\", \"RepoTags\": [], \"Created\": \"2023-09-28T21:19:27.801479409Z\", \"DockerVersion\": \"20.10.23\", \"Labels\": null, \"Architecture\": \"amd64\", \"Os\": \"linux\", \"Layers\": [ \"sha256:cc2447e1835a40530975ab80bb1f872fbab0f2a0faecf2ab16fbbb89b3589438\" ], \"LayersData\": [ { \"MIMEType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"Digest\": \"sha256:cc2447e1835a40530975ab80bb1f872fbab0f2a0faecf2ab16fbbb89b3589438\", \"Size\": 7625728, \"Annotations\": null } ], \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } docker-daemon: docker守护镜像的镜像 alpine:3: 本地镜像的名称 ","date":"2023-11-08","objectID":"/posts/skopeo/:2:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"copy镜像 # skopeo --insecure-policy copy docker://nginx:1.17.6 docker-archive:/tmp/nginx.tar Getting image source signatures Copying blob 8ec398bc0356 done Copying blob 465560073b6f done Copying blob f473f9fd0a8c done Copying config f7bb5701a3 done Writing manifest to image destination Storing signatures # ls -alh /tmp/nginx.tar -rw-r--r-- 1 root root 125M 4月 13 15:22 /tmp/nginx.tar --insecure-policy: 用于忽略安全策略配置文件 docker://nginx:1.17.6: 该命令将会直接通过 http 下载目标镜像 docker-archive: 存储为 /tmp/nginx.tar，此文件可以直接通过 docker load 命令导入 相应的，可以将下载的文件导入到本地 # skopeo copy docker-archive:/tmp/nginx.tar docker-daemon:nginx:latest Getting image source signatures Copying blob 556c5fb0d91b done Copying blob 49434cc20e95 done Copying blob 75248c0d5438 done Copying config f7bb5701a3 done Writing manifest to image destination Storing signatures # docker images nginx REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest f7bb5701a33c 3 months ago 126MB COPY # 也可以将镜像下载到指定目录 # skopeo copy docker://busybox:latest dir:/tmp/busybox Getting image source signatures Copying blob 0669b0daf1fb done Copying config 83aa35aa1c done Writing manifest to image destination Storing signatures # ls -alh /tmp/busybox/ 总用量 760K drwxr-xr-x 2 root root 186 4月 13 15:26 . drwxrwxrwt. 12 root root 4.0K 4月 13 15:25 .. -rw-r--r-- 1 root root 743K 4月 13 15:26 0669b0daf1fba90642d105f3bc2c94365c5282155a33cc65ac946347a90d90d1 -rw-r--r-- 1 root root 1.5K 4月 13 15:26 83aa35aa1c79e4b6957e018da6e322bfca92bf3b4696a211b42502543c242d6f -rw-r--r-- 1 root root 527 4月 13 15:26 manifest.json -rw-r--r-- 1 root root 33 4月 13 15:25 version #或者从指定目录导入到本地 # skopeo copy dir:/tmp/busybox docker-daemon:busybox:latest Getting image source signatures Copying blob 0669b0daf1fb done Copying config 83aa35aa1c done Writing manifest to image destination Storing signatures # docker images busybox REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 83aa35aa1c79 4 weeks ago 1.22MB ","date":"2023-11-08","objectID":"/posts/skopeo/:2:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"删除镜像 skopeo delete docker://localhost:5000/nginx:latest ","date":"2023-11-08","objectID":"/posts/skopeo/:2:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"认证文件 认证文件默认存放在 $HOME/.docker/config.json 文件内容 { \"auths\": { \"myregistrydomain.com:5000\": { \"auth\": \"dGVzdHVzZXI6dGVzdHxxxxxxxx\", \"email\": \"cc@local.com\" } } } ","date":"2023-11-08","objectID":"/posts/skopeo/:2:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"sync 在 OCI 间同步镜像 使用 docke r在 OCI 间同步镜像的时候，需要先把镜像拉下来，打上 tag ，然后在推送到目的 OCI 上。在这个操作的过程中，即占用了存储，又占用了带宽，在同步大的镜像或者大量的镜像的时候，存储会严重影响镜像在 OCI 间同步的效率。skopeo 正好可以解决这个缺点，skopeo 在同步 OCI 镜像的过程中，只占用带宽，不会把镜像下载到本地。 基于 yaml 文件的同步 # sync.yaml ghcr.io: images: kube-vip/kube-vip: - 'v0.6.0' - 'v0.4.4' k3d-io/k3d-tools: - '5.5.2' 同步镜像 skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml repo.local.com/serialt ","date":"2023-11-08","objectID":"/posts/skopeo/:2:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"三、同步镜像 目前，常用的 OCI 仓库有：docker.io，quay.io，gcr.io，registry.k8s.io，ghcr.io 等。众所周知，因为某些原因，这些 OCI 仓库在国内无法访问，而一些项目又严重依赖于存储在这些 OCI 仓库的镜像，虽然有热心的大佬们会把 gcr 和 ghcr 上存储的镜像同步到 docker hub 中，但因为这些被推送到 docker hub 中的镜像不是官方维护的，可能会存在比较大的镜像的同步时间差，某些需要的镜像无法在 docker hub 上找到，同时也容易引起容器镜像的供应链安全问题。因此，可以使用 github action 使用 skopeo 进行同步镜像。 项目地址：sync-image ","date":"2023-11-08","objectID":"/posts/skopeo/:3:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"1、安装sync-image 和 skopeo wget https://github.com/serialt/skopeo/releases/download/v1.13.3/skopeo-linux-amd64 go install github.com/serialt/sync-image@latest ","date":"2023-11-08","objectID":"/posts/skopeo/:3:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"2、配置sync-image yaml 配置文件 # config.yaml # 镜像同步的个数 last: 10 # mcr同步的个数，mcr中包含多个 vscode 容器开发的镜像 mcrLast: 50 autoSyncfile: sync.yaml # 不同步带有以下关键字的镜像的tag exclude: - 'alpha' - 'beta' - 'rc' - 'amd64' - 'ppc64le' - 'arm64' - 'arm' - 's390x' - 'SNAPSHOT' - 'snapshot' - 'debug' - 'master' - 'latest' - 'main' - 'sig' - 'sha' - 'mips' # 需要同步的镜像 images: docker.elastic.co: - elasticsearch/elasticsearch - kibana/kibana - logstash/logstash - beats/filebeat - beats/heartbeat - beats/packetbeat - beats/auditbeat - beats/journalbeat - beats/metricbeat - apm/apm-server - app-search/app-search quay.io: - coreos/flannel - ceph/ceph - cephcsi/cephcsi - csiaddons/k8s-sidecar - csiaddons/volumereplication-operator - prometheus/prometheus - prometheus/alertmanager - prometheus/pushgateway - prometheus/blackbox-exporter - prometheus/node-exporter - prometheus-operator/prometheus-config-reloader - prometheus-operator/prometheus-operator - brancz/kube-rbac-proxy - jetstack/cert-manager-webhook - jetstack/cert-manager-controller - jetstack/cert-manager-cainjector k8s.gcr.io: - conformance - dns/k8s-dns-node-cache - metrics-server/metrics-server - kube-state-metrics/kube-state-metrics - prometheus-adapter/prometheus-adapter registry.k8s.io: - sig-storage/local-volume-provisioner - metrics-server/metrics-server - defaultbackend - ingress-nginx/controller - ingress-nginx/kube-webhook-certgen - sig-storage/nfs-subdir-external-provisioner - sig-storage/csi-node-driver-registrar - sig-storage/csi-provisioner - sig-storage/csi-resizer - sig-storage/csi-snapshotter - sig-storage/snapshot-controller - sig-storage/snapshot-validation-webhook - sig-storage/nfsplugin - sig-storage/csi-attacher - sig-storage/livenessprobe - defaultbackend-amd64 - defaultbackend-arm64 - pause - etcd - kube-proxy - kube-apiserver - kube-scheduler - kube-controller-manager - coredns/coredns - build-image/kube-cross gcr.io: - kaniko-project/executor ghcr.io: - k3d-io/k3d-tools - k3d-io/k3d-proxy - kube-vip/kube-vip mcr.microsoft.com: - devcontainers/base - devcontainers/go docker.io: - flannel/flannel - flannel/flannel-cni-plugin - calico/kube-controllers - serialt/rocky - serialt/alma - calico/cni - calico/pod2daemon-flexvol - calico/kube-controllers - calico/node - rancher/mirrored-flannelcni-flannel-cni-plugin - rancher/mirrored-flannelcni-flanne ","date":"2023-11-08","objectID":"/posts/skopeo/:3:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"3、生成动态同步的 yaml 文件 sync-image -c config.yaml ","date":"2023-11-08","objectID":"/posts/skopeo/:3:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"4、同步镜像 依赖的环境变量 DEST_HUB_USERNAME DEST_HUB_PASSWORD MY_GITHUB_TOKEN 同步的shell脚本 hub=\"docker.io\" repo=\"$hub/${DEST_HUB_USERNAME}\" hub2=\"registry.cn-hangzhou.aliyuncs.com\" repo2=\"$hub2/${DEST_HUB_USERNAME}\" if [ -f sync.yaml ]; then echo \"[Start] sync.......\" sudo skopeo login -u ${DEST_HUB_USERNAME} -p ${DEST_HUB_PASSWORD} ${hub} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml ${repo} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker custom_sync.yaml ${repo} sleep 3 sudo skopeo login -u ${DEST_HUB_USERNAME} -p ${DEST_HUB_PASSWORD} ${hub2} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml ${repo2} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker custom_sync.yaml ${repo2} echo \"[End] done.\" else echo \"[Error]not found sync.yaml!\" fi ","date":"2023-11-08","objectID":"/posts/skopeo/:3:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"5、github action 配置文件 name: sync on: push: branches: - master - main schedule: - cron: \"0 2 * * *\" # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: sync: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21.0' - name: Install dependencies run: | export version=v1.10.0 \u0026\u0026 export arch=amd64 \u0026\u0026 sudo wget https://github.com/lework/skopeo-binary/releases/download/${version}/skopeo-linux-${arch} -O /usr/bin/skopeo \u0026\u0026 sudo chmod +x /usr/bin/skopeo skopeo --version go install github.com/serialt/sync-image@latest - name: generate_sync_yaml env: SRC_HUB_USERNAME: ${{ secrets.SRC_HUB_USERNAME }} DEST_HUB_USERNAME: ${{ secrets.DEST_HUB_USERNAME }} DEST_HUB_PASSWORD: ${{ secrets.DEST_HUB_PASSWORD }} MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }} timeout-minutes: 10 run: | sync-image - name: sync image env: SRC_HUB_USERNAME: ${{ secrets.SRC_HUB_USERNAME }} DEST_HUB_USERNAME: ${{ secrets.DEST_HUB_USERNAME }} DEST_HUB_PASSWORD: ${{ secrets.DEST_HUB_PASSWORD }} run: | bash sync.sh ","date":"2023-11-08","objectID":"/posts/skopeo/:3:5","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["morse编码"],"content":"Morse Code 二叉树记忆法 start E T I A N M S U R W D K G O H V F L P J B X C Y Z Q . - E T .. .- -. -- I A N M ... ..- .-. ..- -.. -.- --. --- S U R W D K G O .... ...- ..-. .-.. .--. .--- -... -..- -.-. -.-- --.. --.- H v F L P J B X C Y Z Q ","date":"2023-11-08","objectID":"/posts/morse-code/:1:0","tags":["morse","morse-code"],"title":"Morse Code","uri":"/posts/morse-code/"},{"categories":["系统或软件换源"],"content":"操作系统或者软件换源加速 ","date":"2023-11-07","objectID":"/posts/mirror-cn/:0:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"1、操作系统 ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"rocky # 8 base sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/rocky|g' \\ -i.bak /etc/yum.repos.d/Rocky*.repo # 8 epel sed -e 's|^metalink=|#metalink=|g' \\ -e 's|^#baseurl=https\\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -e 's|^#baseurl=https\\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -i.bak /etc/yum.repos.d/epel*.repo # 9 base sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/rocky|g' \\ -i.bak /etc/yum.repos.d/rocky*.repo # 9 epel sed -e 's|^metalink=|#metalink=|g' \\ -e 's|^#baseurl=https\\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -e 's|^#baseurl=https\\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -i.bak /etc/yum.repos.d/epel*.repo ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:1","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"ubuntu # http sed -e \"s@http://.*archive.ubuntu.com@http://mirrors.aliyun.com@g\" \\ -e \"s@http://.*security.ubuntu.com@http://mirrors.aliyun.com@g\" \\ -i.bak -i /etc/apt/sources.list # https sed -e \"s@http://.*archive.ubuntu.com@https://mirrors.aliyun.com@g\" \\ -e \"s@http://.*security.ubuntu.com@https://mirrors.aliyun.com@g\" \\ -i.bak -i /etc/apt/sources.list ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:2","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"debian # debian 12及以上 sed -i 's/\\w*.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list.d/debian.sources sed -i \"s@http://mirrors.ustc.edu.cn@https://mirrors.ustc.edu.cn@g\" /etc/apt/sources.list.d/debian.sources # debian 12以下 sed -i 's/\\w*.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list sed -i \"s@http://mirrors.ustc.edu.cn@https://mirrors.ustc.edu.cn@g\" /etc/apt/sources.list ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:3","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"alpine # alpine 官方源 https://dl-cdn.alpinelinux.org/alpine/v3.18/main https://dl-cdn.alpinelinux.org/alpine/v3.18/community # ustc sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories # edge 源 echo \"https://mirrors.ustc.edu.cn/alpine/edge/main\" \u003e\u003e /etc/apk/repositories echo \"https://mirrors.ustc.edu.cn/alpine/edge/community\" \u003e\u003e /etc/apk/repositories echo \"https://mirrors.ustc.edu.cn/alpine/edge/testing\" \u003e\u003e /etc/apk/repositories ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:4","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"2、开发语言类 go export GOPROXY=https://goproxy.cn,direct # aliyun export GOPROXY=https://mirrors.aliyun.com/goproxy/ python export PIP_MIRROR=mirrors.aliyun.com echo -e \"[global]\\nindex-url=https://${PIP_MIRROR}/pypi/simple\\n[install]\\ntrusted-host=${PIP_MIRROR}\" \u003e /etc/pip.conf # 命令配置 pip3 install xxx -i https://mirrors.aliyun.com/pypi/simple/ npm # 设置全局 npm config set registry https://registry.npmmirror.com # cmd npm install -y --registry=https://registry.npmmirror.com # 官方地址 https://registry.npmjs.org/ # 阿里云地址 https://registry.npmmirror.com # 腾讯 http://mirrors.cloud.tencent.com/npm/ # 华为 https://repo.huaweicloud.com/repository/npm/ # 南京大学 https://repo.nju.edu.cn/repository/npm/ ","date":"2023-11-07","objectID":"/posts/mirror-cn/:2:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"3、容器代理 配置模版 { \"insecure-registries\": [ \"repo.local.com\" ], \"exec-opts\": [ \"native.cgroupdriver=systemd\" ], \"registry-mirrors\": [ \"https://docker.mirrors.sjtug.sjtu.edu.cn\", \"https://docker.nju.edu.cn\", \"http://hub-mirror.c.163.com\" ], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"3\" }, \"bip\":\"192.161.20.1/24\", \"dns\": [ \"119.29.29.29\", \"223.5.5.5\" ], \"data-root\": \"/var/lib/docker\", \"features\": { \"buildkit\": true } } docker registry # 上海交大 https://docker.mirrors.sjtug.sjtu.edu.cn # 南京大学 https://docker.nju.edu.cn # dockerproxy https://dockerproxy.com gcr.io # 上海交大 https://gcr-io.mirrors.sjtug.sjtu.edu.cn # 南京大学 https://gcr.nju.edu.cn # dockerproxy https://gcr.dockerproxy.com ghcr.io # 南京大学 https://htghcr.nju.edu.cn # dockerproxy https://ghcr.dockerproxy.com nvcr.io # 南京大学 https://nvcr.nju.edu.cn quay.io # 南京大学 https://quay.nju.edu.cn # dockerproxy quay.dockerproxy.com registry.k8s.io # 南京大学 k8s.mirror.nju.edu.cn # dockerproxy k8s.dockerproxy.com Microsoft Artifact Registry mcr.dockerproxy.com ","date":"2023-11-07","objectID":"/posts/mirror-cn/:3:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["Go req 库文档"],"content":"req Go语言人性化HTTP请求库 特性 轻量级 简单 容易操作JSON和XML 容易调试和日志记录 容易上传和下载文件 容易管理Cookie 容易设置代理 容易设置超时 容易自定义HTTP客户端 安装 go get github.com/serialt/req 概要 req 基于标准库 net/http 实现了一个友好的API. Req 和 Resp 是两个最重要的结构体, 你可以把 Req 看作客户端， 把Resp 看作存放请求及其响应的容器，它们都提供许多简洁方便的API，让你可以很轻松做很多很多事情。 func (r *Req) Post(url string, v ...interface{}) (*Resp, error) 大多情况下，发起请求只有url是必选参数，其它都可选，比如请求头、请求参数、文件或请求体等。 包中含一个默认的 Req 对象, 它所有的公有方法都被req包对应的公有方法包装了，所以大多数情况下，你直接可以把req包看作一个Req对象来使用。 // 创建Req对象来发起请求 r := req.New() r.Get(url) // 直接使用req包发起请求 req.Get(url) 你可以使用 req.New() 方法来创建 *Req 作为一个单独的客户端 例子 基础用法 设置请求头 设置请求参数 设置请求体 调试 输出格式 ToJSON \u0026 ToXML 获取 *http.Response 上传 下载 Cookie 设置超时 设置代理 自定义 http.Client ","date":"2023-10-09","objectID":"/posts/req/:0:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"基础用法 header := req.Header{ \"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW46YWRtaW4=\", } param := req.Param{ \"name\": \"imroc\", \"cmd\": \"add\", } // 只有url必选，其它参数都是可选 r, err = req.Post(\"http://foo.bar/api\", header, param) if err != nil { log.Fatal(err) } r.ToJSON(\u0026foo) // 响应体转成对象 log.Printf(\"%+v\", r) // 打印详细信息 ","date":"2023-10-09","objectID":"/posts/req/:1:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求头 使用 req.Header (它实际上是一个 map[string]string) authHeader := req.Header{ \"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW46YWRtaW4=\", } req.Get(\"https://www.baidu.com\", authHeader, req.Header{\"User-Agent\": \"V1.1\"}) 使用 http.Header header := make(http.Header) header.Set(\"Accept\", \"application/json\") req.Get(\"https://www.baidu.com\", header) 你可以使用 struct 来设置请求头，用 HeaderFromStruct 这个函数来解析你的 struct type HeaderStruct struct { UserAgent string `json:\"User-Agent\"` Authorization string `json:\"Authorization\"` } func main(){ h := HeaderStruct{ \"V1.0.0\", \"roc\", } authHeader := req.HeaderFromStruct(h) req.Get(\"https://www.baidu.com\", authHeader, req.Header{\"User-Agent\": \"V1.1\"}) } 注：请给你的 struct 加上 json tag. ","date":"2023-10-09","objectID":"/posts/req/:2:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求参数 Use req.Param (它实际上是一个 map[string]interface{}) param := req.Param{ \"id\": \"imroc\", \"pwd\": \"roc\", } req.Get(\"http://foo.bar/api\", param) // http://foo.bar/api?id=imroc\u0026pwd=roc req.Post(url, param) // 请求体 =\u003e id=imroc\u0026pwd=roc 使用 req.QueryParam 强制将请求参数拼在url后面 (它实际上也是一个 map[string]interface{}) req.Post(\"http://foo.bar/api\", req.Param{\"name\": \"roc\", \"age\": \"22\"}, req.QueryParam{\"access_token\": \"fedledGF9Hg9ehTU\"}) /* POST /api?access_token=fedledGF9Hg9ehTU HTTP/1.1 Host: foo.bar User-Agent: Go-http-client/1.1 Content-Length: 15 Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Accept-Encoding: gzip age=22\u0026name=roc */ ","date":"2023-10-09","objectID":"/posts/req/:3:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求体 Put string, []byte and io.Reader as body directly. req.Post(url, \"id=roc\u0026cmd=query\") 将对象作为JSON或XML请求体（自动添加 Content-Type 请求头） req.Post(url, req.BodyJSON(\u0026foo)) req.Post(url, req.BodyXML(\u0026bar)) ","date":"2023-10-09","objectID":"/posts/req/:4:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"调试 将全局变量 req.Debug 设置为true，将会把所有请求的详细信息打印在标准输出。 req.Debug = true req.Post(\"http://localhost/test\" \"hi\") ","date":"2023-10-09","objectID":"/posts/req/:5:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"输出格式 您可以使用指定类型的输出格式在日志文件中记录请求和响应的信息。例如，在开发阶段使用％+v格式，可以让你观察请求和响应的细节信息。 在生产阶段使用％v或％-v输出格式，只记录所需要的信息。 ","date":"2023-10-09","objectID":"/posts/req/:6:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%+v 或 %+s 详细输出 r, _ := req.Post(url, header, param) log.Printf(\"%+v\", r) // 输出格式和Debug开启时的格式一样 ","date":"2023-10-09","objectID":"/posts/req/:6:1","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%v 或 %s 简单输出（默认格式） r, _ := req.Get(url, param) log.Printf(\"%v\\n\", r) // GET http://foo.bar/api?name=roc\u0026cmd=add {\"code\":\"0\",\"msg\":\"success\"} log.Prinln(r) // 和上面一样 ","date":"2023-10-09","objectID":"/posts/req/:6:2","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%-v 或 %-s 简单输出并保持所有内容在一行内（请求体或响应体可能包含多行，这种格式会将所有换行、回车替换成\" \", 这在会让你在查日志的时候非常有用） ","date":"2023-10-09","objectID":"/posts/req/:6:3","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"Flag 你可以调用 SetFlags 控制输出内容，决定哪些部分能够被输出。 const ( LreqHead = 1 \u003c\u003c iota // 输出请求首部（包含请求行和请求头） LreqBody // 输出请求体 LrespHead // 输出响应首部（包含响应行和响应头） LrespBody // 输出响应体 Lcost // 输出请求所消耗掉时长 LstdFlags = LreqHead | LreqBody | LrespHead | LrespBody ) req.SetFlags(req.LreqHead | req.LreqBody | req.LrespHead) ","date":"2023-10-09","objectID":"/posts/req/:6:4","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"监控请求耗时 req.SetFlags(req.LstdFlags | req.Lcost) // 输出格式显示请求耗时 r,_ := req.Get(url) log.Println(r) // http://foo.bar/api 3.260802ms {\"code\":0 \"msg\":\"success\"} if r.Cost() \u003e 3 * time.Second { // 检查耗时 log.Println(\"WARN: slow request:\", r) } ","date":"2023-10-09","objectID":"/posts/req/:6:5","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"ToJSON \u0026 ToXML r, _ := req.Get(url) r.ToJSON(\u0026foo) r, _ = req.Post(url, req.BodyXML(\u0026bar)) r.ToXML(\u0026baz) ","date":"2023-10-09","objectID":"/posts/req/:7:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"获取 *http.Response // func (r *Req) Response() *http.Response r, _ := req.Get(url) resp := r.Response() fmt.Println(resp.StatusCode) ","date":"2023-10-09","objectID":"/posts/req/:8:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"上传 使用 req.File 匹配文件 req.Post(url, req.File(\"imroc.png\"), req.File(\"/Users/roc/Pictures/*.png\")) 使用 req.FileUpload 细粒度控制上传 file, _ := os.Open(\"imroc.png\") req.Post(url, req.FileUpload{ File: file, FieldName: \"file\", // FieldName 是表单字段名 FileName: \"avatar.png\", // Filename 是要上传的文件的名称，我们使用它来猜测mimetype，并将其上传到服务器上 }) 使用req.UploadProgress监听上传进度 progress := func(current, total int64) { fmt.Println(float32(current)/float32(total)*100, \"%\") } req.Post(url, req.File(\"/Users/roc/Pictures/*.png\"), req.UploadProgress(progress)) fmt.Println(\"upload complete\") ","date":"2023-10-09","objectID":"/posts/req/:9:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"下载 r, _ := req.Get(url) r.ToFile(\"imroc.png\") 使用req.DownloadProgress监听下载进度 progress := func(current, total int64) { fmt.Println(float32(current)/float32(total)*100, \"%\") } r, _ := req.Get(url, req.DownloadProgress(progress)) r.ToFile(\"hello.mp4\") fmt.Println(\"download complete\") ","date":"2023-10-09","objectID":"/posts/req/:10:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"Cookie 默认情况下，底层的 *http.Client 会自动管理你的cookie（如果服务器给你发了cookie，之后的请求它会自动带上cookie请求头给服务器）, 你可以调用这个方法取消自动管理： req.EnableCookie(false) 你还可以在发送请求的时候自己传入 *http.Cookie cookie := new(http.Cookie) // ...... req.Get(url, cookie) ","date":"2023-10-09","objectID":"/posts/req/:11:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置超时 req.SetTimeout(50 * time.Second) ","date":"2023-10-09","objectID":"/posts/req/:12:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置代理 默认情况下，如果系统环境变量有 http_proxy 或 https_proxy ，req会讲对应的地址作为对应协议的代理，你也可以自定义设置代理，或者将其置为nil，即取消代理。 req.SetProxy(func(r *http.Request) (*url.URL, error) { if strings.Contains(r.URL.Hostname(), \"google\") { return url.Parse(\"http://my.vpn.com:23456\") } return nil, nil }) 设置简单代理（将所有请求都转发到指定代理url地址上） req.SetProxyUrl(\"http://my.proxy.com:23456\") ","date":"2023-10-09","objectID":"/posts/req/:13:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"自定义HTTP客户端 使用 SetClient 改变底层的 *http.Client req.SetClient(client) 给某个请求制定特定的 *http.Client client := \u0026http.Client{Timeout: 30 * time.Second} req.Get(url, client) 改变底层 *http.Client 的某些属性 req.Client().Jar, _ = cookiejar.New(nil) trans, _ := req.Client().Transport.(*http.Transport) trans.MaxIdleConns = 20 trans.TLSHandshakeTimeout = 20 * time.Second trans.DisableKeepAlives = true trans.TLSClientConfig = \u0026tls.Config{InsecureSkipVerify: true} ","date":"2023-10-09","objectID":"/posts/req/:14:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go 库文档"],"content":"Go 原生http库 Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。 ","date":"2023-10-09","objectID":"/posts/go-http/:0:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"一、net/http介绍 Go语言内置的net/http包提供了HTTP客户端和服务端的实现。 HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 ","date":"2023-10-09","objectID":"/posts/go-http/:1:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"二、HTTP客户端 Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。 resp, err := http.Get(\"http://example.com/\") ... resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) 程序在使用完response后必须关闭回复的主体。 resp, err := http.Get(\"http://example.com/\") if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... ","date":"2023-10-09","objectID":"/posts/go-http/:2:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"GET请求示例 package main import ( \"fmt\" \"io\" \"net/http\" ) func main() { resp, err := http.Get(\"https://httpbin.org/uuid\") if err != nil { fmt.Printf(\"get failed, err:%v\\n\", err) return } defer resp.Body.Close() body, err := io.ReadAll(resp.Body) if err != nil { fmt.Printf(\"read from resp.Body failed, err:%v\\n\", err) return } fmt.Print(string(body)) } 自定义请求 package main import ( \"encoding/json\" \"fmt\" \"io\" \"net/http\" \"net/url\" ) type UUID struct { Uuid string `json:\"uuid\"` } func main() { apiURL := \"https://httpbin.org/uuid\" query := url.Values{} query.Add(\"q\", \"golang\") query.Add(\"page\", \"1\") ApiURL, _ := url.ParseRequestURI(apiURL) ApiURL.RawQuery = query.Encode() req, _ := http.NewRequest(\"GET\", ApiURL.String(), nil) req.Header.Add(\"Accept\", \"*/*\") client := \u0026http.Client{} resp, err := client.Do(req) if err != nil { return } defer resp.Body.Close() var uuid UUID body, err := io.ReadAll(resp.Body) if err != nil { fmt.Printf(\"read from resp.Body failed, err:%v\\n\", err) return } json.Unmarshal(body, \u0026uuid) fmt.Println(uuid.Uuid) } ","date":"2023-10-09","objectID":"/posts/go-http/:2:1","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"POST 请求示例 package main import ( \"encoding/json\" \"io\" \"net/http\" \"net/url\" ) type dockerToken struct { Token string `json:\"token\"` } func main() { apiUrl := \"https://hub.docker.com/v2/users/login\" data := url.Values{} data.Set(\"username\", \"username\") data.Set(\"password\", \"password\") resp, err := http.PostForm(apiUrl, data) if err != nil { return } defer resp.Body.Close() _data, _ := io.ReadAll(resp.Body) var tmpT dockerToken json.Unmarshal(_data, \u0026tmpT) } package main import ( \"bytes\" \"io\" \"net/http\" \"net/url\" \"strings\" \"log/slog\" ) func POST1() { apiURL := \"https://httpbin.org/post\" form := url.Values{} form.Add(\"ln\", \"ln222\") form.Add(\"ip\", \"1.1.1.1\") form.Add(\"ua\", \"ua123\") client := \u0026http.Client{} req, _ := http.NewRequest(\"POST\", apiURL, strings.NewReader(form.Encode())) req.Header.Set(\"User-Agent\", \"test\") req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\") // 发送请求 resp, err := client.Do(req) if err != nil { slog.Error(\"POST request failed\", \"err\", err) return } defer resp.Body.Close() // 读取内容 body, err := io.ReadAll(resp.Body) if err != nil { slog.Error(\"POST request\", \"err\", err) } else { slog.Info(string(body)) } } func POSTJson() { apiURL := \"https://httpbin.org/post\" var jsonStr = []byte(`{\"title\":\"this is a title\", \"cate\": 1}`) client := \u0026http.Client{} req, _ := http.NewRequest(\"POST\", apiURL, bytes.NewBuffer(jsonStr)) req.Header.Set(\"User-Agent\", \"test\") req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\") // 发送请求 resp, err := client.Do(req) if err != nil { slog.Error(\"POST request failed\", \"err\", err) return } defer resp.Body.Close() // 读取内容 body, err := io.ReadAll(resp.Body) if err != nil { slog.Error(\"POST request\", \"err\", err) } else { slog.Info(string(body)) } } func main() { // POST1() POSTJson() } ","date":"2023-10-09","objectID":"/posts/go-http/:2:2","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Kubernetes"],"content":"Dev in kubernetes ​ 传统的开发模式中，是代码存放在本地，使用 IDE 进行编辑和 debug 。但随着容器化火了之后，很多单一服务都进行了拆分，微服务化。在开发阶段，需要本地同时启动多个服务，这使得本地开发调试变得越来越困难。Okteto 是一个通过在 Kubernetes 中来开发和测试代码的应用程序开发工具。可以通过 Okteto 在 Kubernetes 中一键为我们启动一个开发环境，非常简单方便。Google 推出的 Skaffold 只是把 CICD 集成到本地，使用起来也比较困难。Okteto 的工作原理是在 kubernetes 中启动一个服务，把本地代码同步到 pod 中，然后执行命令让服务运行起来，Okteto 可以进行端口的转发，转发pod里服务的端口到本地，在进行 debug 的时候，pod里启动的端口可以被 kubernetes 内的其他服务所访问，本地转发的端口可以被本地的工具（例如 postman ）访问。 okteto官网文档：https://www.okteto.com/docs Go 配置文档：https://www.okteto.com/docs/samples/golang/ 示例环境： vscode 1.82.1(需要安装 Remote - Kubernetes 插件，插件code：okteto.remote-kubernetes) k3d mac ","date":"2023-09-26","objectID":"/posts/okteto/:0:0","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"安装与配置 下载okteto：https://github.com/okteto/okteto/releases [crab@Sugar ~]🐳 wget https://ghproxy.com/https://github.com/okteto/okteto/releases/download/2.20.0/okteto-Darwin-arm64 [crab@Sugar ~]🐳 chmod +x okteto-Darwin-arm64 [crab@Sugar ~]🐳 sudo mv okteto-Darwin-arm64 /usr/local/bin/okteto ","date":"2023-09-26","objectID":"/posts/okteto/:1:0","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"下载示例代码 [crab@Sugar ~]🐳 git clone https://github.com/okteto/go-getting-started go-okteto [crab@Sugar ~]🐳 cd go-okteto ","date":"2023-09-26","objectID":"/posts/okteto/:1:1","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"配置port-forward端口 需要转发两个，一个是服务的端口，另一个是debug使用的端口 okteto.yaml build: hello-world: image: serialt/go-hello-world:1.0.0 context: . deploy: - kubectl apply -f k8s.yml dev: hello-world: # 被替换的服务名 image: okteto/golang:1 command: bash sync: - .:/usr/src/app volumes: - /go - /root/.cache securityContext: capabilities: add: - SYS_PTRACE forward: - 2345:2345 - 8080:8080 # \u003c---- 增加8080服务端口转发 设置okteto context，okteto 默认会优先使用KUBECONFIG环境变量的配置文件，如果没有设置，则使用 ~/.kube/config文件 [crab@Sugar go-okteto]🐳 okteto context ✓ Context 'k3d-mycluster' selected ✓ Using dev @ k3d-mycluster ","date":"2023-09-26","objectID":"/posts/okteto/:1:2","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"启动服务 [crab@Sugar go-okteto]🐳 okteto up i Using dev @ k3d-mycluster as context i 'go-getting-started' was already deployed. To redeploy run 'okteto deploy' or 'okteto up --deploy' i Images were already built. To rebuild your images run 'okteto build' or 'okteto deploy --build' ✓ Images successfully pulled ✓ Files synchronized Context: k3d-mycluster Namespace: dev Name: hello-world Forward: 2345 -\u003e 2345 8080 -\u003e 8080 Welcome to your development container. Happy coding! dev:hello-world app\u003e dev:hello-world app\u003e ls Dockerfile LICENSE Makefile README.md bashrc go.mod k8s.yml main.go okteto.yml ","date":"2023-09-26","objectID":"/posts/okteto/:1:3","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"远程开发 # okteto终端 dev:hello-world app\u003e go run main.go Starting hello-world server... # 终端测试 [crab@Sugar ~]🐳 curl 127.0.0.1:8080 Hello world! ","date":"2023-09-26","objectID":"/posts/okteto/:1:4","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"远程调试 # okteto终端, 执行dlv命令 dev:hello-world app\u003e dlv debug --headless --listen=:2345 --log --api-version=2 API server listening at: [::]:2345 2023-09-26T13:40:51Z warning layer=rpc Listening for remote connections (connections are not authenticated nor encrypted) 2023-09-26T13:40:51Z info layer=debugger launching process with args: [./__debug_bin3213431902] 2023-09-26T13:40:51Z debug layer=debugger Adding target 575 \"/usr/src/app/__debug_bin3213431902\" # main.go 打上debug标记 func helloServer(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Hello world from Okteto!, k3d is great! \") fmt.Println(\"okteto ccccccc\") # 标记此行 } 在vscode debug中点击开始debug 使用命令请求 http://127.0.0.1:8080，即可debug到标记点 [sugar@Sugar go-okteto]🐳 curl http://127.0.0.1:8080 Hello world from Okteto!, k3d is great! ","date":"2023-09-26","objectID":"/posts/okteto/:1:5","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["vscode"],"content":"Debug shell 1、安装插件 安装bashdb插件 rogalmic.bash-debug 2、增加一个vscode launch.json配置文件 Select Debug -\u003e Add Configuration to add custom debug configuration 示例： { \"configurations\": [ { \"type\": \"bashdb\", \"request\": \"launch\", \"name\": \"Bash-Debug\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${workspaceFolder}/ccc.sh\", \"args\": [] }, ] } 就可以像debug其他语言一样进行调试shell脚本 ","date":"2023-09-24","objectID":"/posts/debug-shell-in-vscode/:0:0","tags":["shell"],"title":"Debug Shell in VSCode","uri":"/posts/debug-shell-in-vscode/"},{"categories":["mirror-web"],"content":"清华镜像网页搭建镜像站 tuna mirror-web地址：https://github.com/tuna/mirror-web.git tuna mirror-web基于jekyll开发，由于ruby环境安装复杂，因此采用docker编译，但在build镜像的时候，出现安装包依赖安装失败，在多次测试后，无法build成镜像。前段时间，在查看mirror-web段issues时，有人询问mirror-web段README.md文档的下一步，官方给了一点提示，有关于基于nginx的第三方模块来实现目录第渲染的提示说明，再次尝试后，经历各种困难和折磨，终于摸索出。 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:0","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"1、下载mirror-web的jekyll编译环境 tuna的编译镜像：tunathu/mirror-web 在下载tunathu/mirror-web时发生了一个小问题，由于在国内使用的docker镜像加速，下载的镜像是旧版本的，但境外的服务器下载的镜像是最新的，在踩坑后果断推到自己的dockerhub上，新的下载地址：serialt/tuna-mirror-web。 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:1","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"2、下载github仓库 git clone https://github.com/tuna/mirror-web.git /opt/mirror-web ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:2","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"3、下载额外资源和编译 cd /opt/mirror-web wget https://mirrors.tuna.tsinghua.edu.cn/static/tunasync.json -O static/tunasync.json wget https://mirrors.tuna.tsinghua.edu.cn/static/tunet.json -O static/tunet.json mkdir -p static/status wget https://mirrors.tuna.tsinghua.edu.cn/static/status/isoinfo.json -O static/status/isoinfo.json docker run -it -v /opt/mirror-web/:/data serialt/tuna-mirror-web:20211006 编译的后静态文件在_site里 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:3","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"4、编译nginx 需要安装第三方模块 modules/ngx_http_js_module.so modules/ngx_http_fancyindex_module.so [root@serialt nginx]# ll 总用量 1068 drwxr-xr-x 9 sonar sonar 186 10月 5 22:27 nginx-1.20.1 -rw-r--r-- 1 root root 1061461 5月 25 23:34 nginx-1.20.1.tar.gz drwxrwxr-x 3 root root 217 10月 27 2020 ngx-fancyindex-0.5.1 -rw-r--r-- 1 root root 25148 10月 27 2020 ngx-fancyindex-0.5.1.tar.xz drwxr-xr-x 10 root root 228 10月 6 15:49 njs # njs下载 git clone https://github.com/nginx/njs # ngx-fancyindex 下载 wget https://github.com/aperezdc/ngx-fancyindex/releases/download/v0.5.1/ngx-fancyindex-0.5.1.tar.xz 编译： [root@serialt nginx]# ls nginx-1.20.1 nginx-1.20.1.tar.gz ngx-fancyindex-0.5.1 ngx-fancyindex-0.5.1.tar.xz njs [root@serialt nginx]# cd nginx-1.20.1/ [root@serialt nginx-1.20.1]# ./configure --prefix=/usr/local/nginx --with-pcre --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --add-dynamic-module=/root/nginx/ngx-fancyindex-0.5.1 --add-dynamic-module=/root/nginx/njs/nginx # add m 3997 [2022-02-25 00:49:21] [root] [10.5.0.10] ./configure --with-compat --add-dynamic-module=/root/github/tuna-mirror-web/njs-0.6.2/nginx 3998 [2022-02-25 00:49:31] [root] [10.5.0.10] make modules nginx配置文件内容 [root@serialt mirrors]# cat /usr/local/nginx/conf/nginx.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; load_module modules/ngx_http_js_module.so; load_module modules/ngx_http_fancyindex_module.so; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; map $http_user_agent $isbrowser { default 0; \"~*validation server\" 0; \"~*mozilla\" 1; } js_path /opt/mirror-web/_site/static/njs; js_include /opt/mirror-web/_site/static/njs/all.njs; #js_path /opt/mirror-web/static/njs; #js_include /opt/mirror-web/static/njs/all.njs; server { listen 8007; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #root /opt/mirror-web/_site; fancyindex_header /fancy-index/before; fancyindex_footer /fancy-index/after; fancyindex_exact_size off; fancyindex_time_format \"%d %b %Y %H:%M:%S +0000\"; fancyindex_name_length 256; error_page 404 /404.html; location /fancy-index { internal; root /opt/mirror-web/_site; subrequest_output_buffer_size 100k; location = /fancy-index/before { js_content fancyIndexBeforeRender; } location = /fancy-index/after { js_content fancyIndexAfterRender; } } location / { root /opt/mirror-web/_site; index index.html index.htm; #try_files /_site/$uri $uri/ /_site/$uri; fancyindex on; } # location / { # root html; # index index.html index.htm; # } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } [root@serialt mirrors]# ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:4","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"5、镜像资源暴露 方法1：以软链接形式存放在/opt/mirror-web/_site中 [root@serialt _site]# pwd /opt/mirror-web/_site [root@serialt _site]# ll 总用量 160 -rw-r--r-- 1 root root 16415 10月 6 15:37 404.html drwxr-xr-x 2 root root 6 10月 6 17:14 cc drwxr-xr-x 2 root root 19 10月 6 17:14 centos drwxr-xr-x 2 root root 94 10月 6 09:25 fancy-index -rw-r--r-- 1 root root 36650 10月 6 15:37 feed.xml drwxr-xr-x 103 root root 4096 10月 6 09:25 help -rw-r--r-- 1 root root 27679 10月 6 15:37 index.html -rw-r--r-- 1 root root 20728 10月 6 15:37 legacy_index.html -rw-r--r-- 1 root root 18092 10月 6 15:37 LICENSE drwxr-xr-x 47 root root 4096 10月 6 09:25 news -rw-r--r-- 1 root root 58 10月 6 15:37 robots.txt -rw-r--r-- 1 root root 19134 10月 6 15:37 sitemap.xml drwxr-xr-x 8 root root 115 10月 6 15:37 static drwxr-xr-x 2 root root 24 10月 6 09:25 status 方法二：把/opt/mirror-web/_site里的文件以软链接的方式链接到镜像的跟目录（建议使用） ln -snf /opt/mirror-web/_site/* /opt/imau 目录描述文件：_data/options.yml 站点资源显示控制：static/tunasync.json tunasync.json [ { \"name\": \"ant\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"book\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"centos\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"dev\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"frp\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"git\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"go\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"grafana\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"iso\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"jdk\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"jmeter\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"kubernetes\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"mac\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"monitor\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"node\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"root-ca\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"other\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"printer\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"prometheus\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"pycharm\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"python\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"repo\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"script\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"test\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"tool\", \"is_master\": true, \"status\": \"success\" } ] \"last_update\": \"2022-01-11 16:39:37 +0800\", \"last_update_ts\": 1641890377, \"last_started\": \"2022-01-11 16:39:21 +0800\", \"last_started_ts\": 1641890361, \"last_ended\": \"2022-01-11 16:39:37 +0800\", \"last_ended_ts\": 1641890377, \"next_schedule\": \"2022-01-11 22:39:37 +0800\", \"next_schedule_ts\": 1641911977, \"upstream\": \"rsync://msync.centos.org/CentOS/\", - status: 'success' last_update: '-' name: \"AUR\" url: 'https://aur.tuna.tsinghua.edu.cn/' upstream: 'https://aur.archlinux.org/' is_master: true options.yml # Content Related mirror_desc: - name: git desc: git 二进制编译版本 - name: go desc: golang 开发环境 - name: grafana desc: grafana 的安装包 - name: helm desc: helm 的二进制发行包 - name: ios desc: 镜像文件，如centos, ubuntu, rocky等 - name: jdk desc: java 开发环境安装包 new_mirrors: - hugging-face-models - endeavouros - ubuntukylin - putty - postmarketOS - postmarketOS-images - obs-studio - stellarium unlisted_mirrors: - status: 'success' last_update: '-' name: \"AUR\" url: 'https://aur.tuna.tsinghua.edu.cn/' upstream: 'https://aur.archlinux.org/' is_master: true - link_to: 'osdn' name: \"manjaro-cd\" url: '/osdn/storage/g/m/ma/manjaro/' - link_to: 'osdn' name: \"manjaro-arm-cd\" url: '/osdn/storage/g/m/ma/manjaro-arm/' - link_to: 'osdn' name: \"mxlinux-isos\" url: '/osdn/storage/g/m/mx/mx-linux/ISOs/' - link_to: 'osdn' name: \"garuda-linux\" url: '/osdn/storage/g/g/ga/garuda-linux/' - link_to: 'osdn' name: \"linuxlite-cd\" url: '/osdn/storage/g/l/li/linuxlite/' - link_to: 'github-release' name: \"prometheus\" url: '/github-rele","date":"2023-09-24","objectID":"/posts/tuna-web/:1:5","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"6、docker镜像使用 静态文件编译 构建 Jekyll 的 docker 镜像环境复杂，建议直接使用官方或者已经存在的镜像tunathu/mirror-web或者serialt/tuna-mirror-web [root@tc ~]# docker run -it -v /path/to/mirror-web/:/data serialt/tuna-mirror-web 一些动态数据已经下载，若需要最新的，可以就行以下操作,然后在构建 下载最新的动态数据文件 wget https://mirrors.tuna.tsinghua.edu.cn/static/tunasync.json -O static/tunasync.json wget https://mirrors.tuna.tsinghua.edu.cn/static/tunet.json -O static/tunet.json mkdir -p static/status wget https://mirrors.tuna.tsinghua.edu.cn/static/status/isoinfo.json -O static/status/isoinfo.json 运行服务 docker镜像网页根目录: /opt/mirror-web 镜像站资源根目录: /opt/mirror 启动服务 docker run -tid -v /opt/tuna-mirror-web/_site:/opt/mirror-web -v /opt/mirror:/opt/mirror -p 8099:80 --name=tuna-mirror-nginx serialt/tuna-mirror-web-nginx:7b0c89d version: \"3\" networks: tuna-mirror-nginx: external: false services: tuna-mirror-nginx: image: serialt/tuna-mirror-web-nginx:latest container_name: mirror-nginx hostname: mirror-nginx restart: always networks: - tuna-mirror-nginx volumes: - \"/etc/localtime:/etc/localtime:ro\" - \"/opt/mirror-web/_site:/opt/mirror-web\" - \"/opt/mirror:/opt/mirror\" ports: - \"80:80\" dns: - 223.5.5.5 - 223.6.6.6 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:6","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"新镜像站版本发布 docker run -it --rm -v /opt/tuna-mirror-web:/data serialt/tuna-mirror-web docker restart tuna-mirror-nginx ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:7","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"编写说明 _data/options.yml: 是显示在镜像站主页对各个目录的说明 static/tunasync.json: 是对当前repo的同步信息的描述，可以自行编辑，也可以从tuna上下载 help: help目录里存有各个repo的帮助信息，在主页上会显示有个\"?\" news: 镜像站的新闻信息 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:8","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"help 说明 permalink 是表示help的首页的路径，必须要有 --- layout: help category: help mirrorid: app permalink: /help/app/ --- ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:9","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["Kubernetes"],"content":"helm oci ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:0","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"缘由 Helm 3.8 版本开始，支持使用oci进行存储chart。镜像存储常用的Harbor在v1.6版本开始支持Helm Chart仓库功能， chart仓库由chartmuseum以插件的方式提供。随着兼容OCI规范的Helm Chart在社区上被更广泛地接受，Helm Chart能以Artifact的形式在Harbor中存储和管理，不再依赖ChartMuseum，因此Harbor在v2.8.0版本中，移除对ChartMuseum的支持。 ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:1","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"registry 仓库使用 基本使用 ### registry # 登录 helm registry login -u serialt docker.io # 注销 helm registry logout docker.io # pull chart helm fetch oci://docker.io/serialt/loki-stack --version=2.9.11 # push chart helm push loki-stack-2.9.11.tgz oci://docker.io/serialt oci支持的其他命令 helm pull helm show helm template helm install helm upgrade $ helm pull oci://localhost:5000/helm-charts/mychart --version 0.1.0 Pulled: localhost:5000/helm-charts/mychart:0.1.0 Digest: sha256:0be7ec9fb7b962b46d81e4bb74fdcdb7089d965d3baca9f85d64948b05b402ff $ helm show all oci://localhost:5000/helm-charts/mychart --version 0.1.0 apiVersion: v2 appVersion: 1.16.0 description: A Helm chart for Kubernetes name: mychart ... $ helm template myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0 --- # Source: mychart/templates/serviceaccount.yaml apiVersion: v1 kind: ServiceAccount ... $ helm install myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0 NAME: myrelease LAST DEPLOYED: Wed Oct 27 15:11:40 2021 NAMESPACE: default STATUS: deployed REVISION: 1 NOTES: ... $ helm upgrade myrelease oci://localhost:5000/helm-charts/mychart --version 0.2.0 Release \"myrelease\" has been upgraded. Happy Helming! NAME: myrelease LAST DEPLOYED: Wed Oct 27 15:12:05 2021 NAMESPACE: default STATUS: deployed REVISION: 2 NOTES: ... ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:2","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"迁移 chart repo 到 oci 仓库 基于 github action 镜像 helm repo 仓库到 docker hub，以加速 helm repo 到访问。 migrate-chart ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:3","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"}]