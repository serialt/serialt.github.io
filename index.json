[{"categories":["同步oci镜像"],"content":"镜像同步 参考链接： https://lework.github.io/2020/04/13/skopeo/ https://blog.k8s.li/skopeo.html 日常工作中，需要将各种镜像搬到对应的仓库中，docker 适合于构建镜像，将镜像推送于仓库中。镜像被推送到仓库中后，如果需要对镜像进行搬运，在仓库不提供这个功能的情况下，同步镜像是比较困难的。 skopeo 是红帽开源的容器镜像管理工具。相比于docker，它有一下的优点： 支持多个平台：skopeo 支持 Linux，Mac 和 Windows。 无需 docker 或者 podman：skopeo 可以构建为单一的 cli，不依赖于 docker 服务或者 podman。 支持多个 OCI 镜像仓库间同步：支持 OCI 的镜像托管服务，都可以相互同步。 支持多架构镜像同步：可以同步多种架构的镜像。 镜像验签：skopeo 支持镜像签名，可确保镜像的完整性和可靠性。 ","date":"2023-11-08","objectID":"/posts/skopeo/:0:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"一、编译skopeo skopeo 官方并不提供编译好的静态二进制可执行文件，常见的系统源中已经包含了 skopeo，但由于 skopeo 的版本迭代比较快，新的功能也随之增加，部分操作系统里提供的安装包版本可能比较低，无法适用，且 skopeo 大多都是链接了动态库，无法通用于多个 linux 发行版，因此可以借助docker实现skopeo的静态编译。 基于github action构建skopeo: skopeo ","date":"2023-11-08","objectID":"/posts/skopeo/:1:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"下载 skopeo 源码 # download source code git clone --depth=1 https://github.com/containers/skopeo.git ","date":"2023-11-08","objectID":"/posts/skopeo/:1:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建build镜像的Dockerfile 国内构建则需要修改 alpine 和 go 镜像地址，可直连 github 的可以忽略此步 FROM golang:1.19-alpine3.16 AS builder ENV LANG=C.UTF-8 ENV TZ=Asia/Shanghai ENV CGO_ENABLED=0 ENV GOPROXY=https://goproxy.cn,direct RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories RUN apk update --no-cache \u0026\u0026 apk add --no-cache ca-certificates ","date":"2023-11-08","objectID":"/posts/skopeo/:1:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建 build 镜像 docker build -t skopeo-build . ","date":"2023-11-08","objectID":"/posts/skopeo/:1:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"构建 skopeo 静态二进制可执行文件 cd skopeo/ # 构建 linux amd64 架构 docker run --rm -t -v $PWD:/build skopeo-build sh -c \"apk update \u0026\u0026 apk add gpgme btrfs-progs-dev llvm13-dev gcc musl-dev \u0026\u0026 cd /build \u0026\u0026 CGO_ENABLE=0 GO111MODULE=on GOOS=linux GOARCH=amd64 go build -mod=vendor '-buildmode=pie' -ldflags '-extldflags -static' -gcflags '' -tags 'exclude_graphdriver_devicemapper exclude_graphdriver_btrfs containers_image_openpgp' -o ./bin/skopeo-linux-amd64 ./cmd/skopeo \" # 构建 linux arm64 架构 docker run --rm -t -v $PWD:/build skopeo-build sh -c \"apk update \u0026\u0026 apk add gpgme btrfs-progs-dev llvm13-dev gcc musl-dev \u0026\u0026 cd /build \u0026\u0026 CGO_ENABLE=0 GO111MODULE=on GOOS=linux GOARCH=arm64 go build -mod=vendor '-buildmode=pie' -ldflags '-extldflags -static' -gcflags '' -tags 'exclude_graphdriver_devicemapper exclude_graphdriver_btrfs containers_image_openpgp' -o ./bin/skopeo-linux-arm64 ./cmd/skopeo \" ","date":"2023-11-08","objectID":"/posts/skopeo/:1:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"二、skopeo 命令使用 [root@tc ~]# skopeo -v skopeo version 1.11.1-dev [root@tc ~]# skopeo --help Various operations with container images and container image registries Usage: skopeo [flags] skopeo [command] Available Commands: copy Copy an IMAGE-NAME from one location to another delete Delete image IMAGE-NAME generate-sigstore-key Generate a sigstore public/private key pair help Help about any command inspect Inspect image IMAGE-NAME list-tags List tags in the transport/repository specified by the SOURCE-IMAGE login Login to a container registry logout Logout of a container registry manifest-digest Compute a manifest digest of a file standalone-sign Create a signature using local files standalone-verify Verify a signature using local files sync Synchronize one or more images from one location to another Flags: --command-timeout duration timeout for the command execution --debug enable debug output -h, --help help for skopeo --insecure-policy run the tool without any policy check --override-arch ARCH use ARCH instead of the architecture of the machine for choosing images --override-os OS use OS instead of the running OS for choosing images --override-variant VARIANT use VARIANT instead of the running architecture variant for choosing images --policy string Path to a trust policy file --registries.d DIR use registry configuration files in DIR (e.g. for container signature storage) --tmpdir string directory used to store temporary files -v, --version Version for Skopeo Use \"skopeo [command] --help\" for more information about a command. # 登录与登出 oci skopeo login -u username docker.io skopeo logout docker.io 不下载镜像情况下获取镜像信息 [root@tc ~]# skopeo inspect docker://docker.io/alpine { \"Name\": \"docker.io/library/alpine\", \"Digest\": \"sha256:eece025e432126ce23f223450a0326fbebde39cdf496a85d8c016293fc851978\", \"RepoTags\": [ \"20220316\", \"20220328\", \"20220715\", \"20221110\", \"20230208\", \"20230329\", \"20230901\", \"3\", \"3.17\", \"3.17.0\", \"3.17.0_rc1\", \"3.17.1\", \"3.17.2\", \"3.17.3\", \"3.17.4\", \"3.17.5\", \"3.18\", \"3.18.0\", \"3.18.2\", \"3.18.3\", \"3.18.4\", \"edge\", \"latest\" ], \"Created\": \"2023-09-28T21:19:27.801479409Z\", \"DockerVersion\": \"20.10.23\", \"Labels\": null, \"Architecture\": \"amd64\", \"Os\": \"linux\", \"Layers\": [ \"sha256:96526aa774ef0126ad0fe9e9a95764c5fc37f409ab9e97021e7b4775d82bf6fa\" ], \"LayersData\": [ { \"MIMEType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"Digest\": \"sha256:96526aa774ef0126ad0fe9e9a95764c5fc37f409ab9e97021e7b4775d82bf6fa\", \"Size\": 3401967, \"Annotations\": null } ], \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } docker://: 是使用 Docker Registry HTTP API V2 进行连接远端 docker.io: 远程仓库 alpine: 镜像名称 获取本地镜像信息 [root@tc ~]# skopeo inspect docker-daemon:alpine:3 { \"Name\": \"docker.io/library/alpine\", \"Digest\": \"sha256:844bc35fdf7a96e5b6bf5e76e20989a797cc75976fad73275061a36f448b92b9\", \"RepoTags\": [], \"Created\": \"2023-09-28T21:19:27.801479409Z\", \"DockerVersion\": \"20.10.23\", \"Labels\": null, \"Architecture\": \"amd64\", \"Os\": \"linux\", \"Layers\": [ \"sha256:cc2447e1835a40530975ab80bb1f872fbab0f2a0faecf2ab16fbbb89b3589438\" ], \"LayersData\": [ { \"MIMEType\": \"application/vnd.docker.image.rootfs.diff.tar.gzip\", \"Digest\": \"sha256:cc2447e1835a40530975ab80bb1f872fbab0f2a0faecf2ab16fbbb89b3589438\", \"Size\": 7625728, \"Annotations\": null } ], \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\" ] } docker-daemon: docker守护镜像的镜像 alpine:3: 本地镜像的名称 ","date":"2023-11-08","objectID":"/posts/skopeo/:2:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"copy镜像 # skopeo --insecure-policy copy docker://nginx:1.17.6 docker-archive:/tmp/nginx.tar Getting image source signatures Copying blob 8ec398bc0356 done Copying blob 465560073b6f done Copying blob f473f9fd0a8c done Copying config f7bb5701a3 done Writing manifest to image destination Storing signatures # ls -alh /tmp/nginx.tar -rw-r--r-- 1 root root 125M 4月 13 15:22 /tmp/nginx.tar --insecure-policy: 用于忽略安全策略配置文件 docker://nginx:1.17.6: 该命令将会直接通过 http 下载目标镜像 docker-archive: 存储为 /tmp/nginx.tar，此文件可以直接通过 docker load 命令导入 相应的，可以将下载的文件导入到本地 # skopeo copy docker-archive:/tmp/nginx.tar docker-daemon:nginx:latest Getting image source signatures Copying blob 556c5fb0d91b done Copying blob 49434cc20e95 done Copying blob 75248c0d5438 done Copying config f7bb5701a3 done Writing manifest to image destination Storing signatures # docker images nginx REPOSITORY TAG IMAGE ID CREATED SIZE nginx latest f7bb5701a33c 3 months ago 126MB COPY # 也可以将镜像下载到指定目录 # skopeo copy docker://busybox:latest dir:/tmp/busybox Getting image source signatures Copying blob 0669b0daf1fb done Copying config 83aa35aa1c done Writing manifest to image destination Storing signatures # ls -alh /tmp/busybox/ 总用量 760K drwxr-xr-x 2 root root 186 4月 13 15:26 . drwxrwxrwt. 12 root root 4.0K 4月 13 15:25 .. -rw-r--r-- 1 root root 743K 4月 13 15:26 0669b0daf1fba90642d105f3bc2c94365c5282155a33cc65ac946347a90d90d1 -rw-r--r-- 1 root root 1.5K 4月 13 15:26 83aa35aa1c79e4b6957e018da6e322bfca92bf3b4696a211b42502543c242d6f -rw-r--r-- 1 root root 527 4月 13 15:26 manifest.json -rw-r--r-- 1 root root 33 4月 13 15:25 version #或者从指定目录导入到本地 # skopeo copy dir:/tmp/busybox docker-daemon:busybox:latest Getting image source signatures Copying blob 0669b0daf1fb done Copying config 83aa35aa1c done Writing manifest to image destination Storing signatures # docker images busybox REPOSITORY TAG IMAGE ID CREATED SIZE busybox latest 83aa35aa1c79 4 weeks ago 1.22MB ","date":"2023-11-08","objectID":"/posts/skopeo/:2:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"删除镜像 skopeo delete docker://localhost:5000/nginx:latest ","date":"2023-11-08","objectID":"/posts/skopeo/:2:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"认证文件 认证文件默认存放在 $HOME/.docker/config.json 文件内容 { \"auths\": { \"myregistrydomain.com:5000\": { \"auth\": \"dGVzdHVzZXI6dGVzdHxxxxxxxx\", \"email\": \"cc@local.com\" } } } ","date":"2023-11-08","objectID":"/posts/skopeo/:2:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"sync 在 OCI 间同步镜像 使用 docke r在 OCI 间同步镜像的时候，需要先把镜像拉下来，打上 tag ，然后在推送到目的 OCI 上。在这个操作的过程中，即占用了存储，又占用了带宽，在同步大的镜像或者大量的镜像的时候，存储会严重影响镜像在 OCI 间同步的效率。skopeo 正好可以解决这个缺点，skopeo 在同步 OCI 镜像的过程中，只占用带宽，不会把镜像下载到本地。 基于 yaml 文件的同步 # sync.yaml ghcr.io: images: kube-vip/kube-vip: - 'v0.6.0' - 'v0.4.4' k3d-io/k3d-tools: - '5.5.2' 同步镜像 skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml repo.local.com/serialt ","date":"2023-11-08","objectID":"/posts/skopeo/:2:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"三、同步镜像 目前，常用的 OCI 仓库有：docker.io，quay.io，gcr.io，registry.k8s.io，ghcr.io 等。众所周知，因为某些原因，这些 OCI 仓库在国内无法访问，而一些项目又严重依赖于存储在这些 OCI 仓库的镜像，虽然有热心的大佬们会把 gcr 和 ghcr 上存储的镜像同步到 docker hub 中，但因为这些被推送到 docker hub 中的镜像不是官方维护的，可能会存在比较大的镜像的同步时间差，某些需要的镜像无法在 docker hub 上找到，同时也容易引起容器镜像的供应链安全问题。因此，可以使用 github action 使用 skopeo 进行同步镜像。 项目地址：sync-image ","date":"2023-11-08","objectID":"/posts/skopeo/:3:0","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"1、安装sync-image 和 skopeo wget https://github.com/serialt/skopeo/releases/download/v1.13.3/skopeo-linux-amd64 go install github.com/serialt/sync-image@latest ","date":"2023-11-08","objectID":"/posts/skopeo/:3:1","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"2、配置sync-image yaml 配置文件 # config.yaml # 镜像同步的个数 last: 10 # mcr同步的个数，mcr中包含多个 vscode 容器开发的镜像 mcrLast: 50 autoSyncfile: sync.yaml # 不同步带有以下关键字的镜像的tag exclude: - 'alpha' - 'beta' - 'rc' - 'amd64' - 'ppc64le' - 'arm64' - 'arm' - 's390x' - 'SNAPSHOT' - 'snapshot' - 'debug' - 'master' - 'latest' - 'main' - 'sig' - 'sha' - 'mips' # 需要同步的镜像 images: docker.elastic.co: - elasticsearch/elasticsearch - kibana/kibana - logstash/logstash - beats/filebeat - beats/heartbeat - beats/packetbeat - beats/auditbeat - beats/journalbeat - beats/metricbeat - apm/apm-server - app-search/app-search quay.io: - coreos/flannel - ceph/ceph - cephcsi/cephcsi - csiaddons/k8s-sidecar - csiaddons/volumereplication-operator - prometheus/prometheus - prometheus/alertmanager - prometheus/pushgateway - prometheus/blackbox-exporter - prometheus/node-exporter - prometheus-operator/prometheus-config-reloader - prometheus-operator/prometheus-operator - brancz/kube-rbac-proxy - jetstack/cert-manager-webhook - jetstack/cert-manager-controller - jetstack/cert-manager-cainjector k8s.gcr.io: - conformance - dns/k8s-dns-node-cache - metrics-server/metrics-server - kube-state-metrics/kube-state-metrics - prometheus-adapter/prometheus-adapter registry.k8s.io: - sig-storage/local-volume-provisioner - metrics-server/metrics-server - defaultbackend - ingress-nginx/controller - ingress-nginx/kube-webhook-certgen - sig-storage/nfs-subdir-external-provisioner - sig-storage/csi-node-driver-registrar - sig-storage/csi-provisioner - sig-storage/csi-resizer - sig-storage/csi-snapshotter - sig-storage/snapshot-controller - sig-storage/snapshot-validation-webhook - sig-storage/nfsplugin - sig-storage/csi-attacher - sig-storage/livenessprobe - defaultbackend-amd64 - defaultbackend-arm64 - pause - etcd - kube-proxy - kube-apiserver - kube-scheduler - kube-controller-manager - coredns/coredns - build-image/kube-cross gcr.io: - kaniko-project/executor ghcr.io: - k3d-io/k3d-tools - k3d-io/k3d-proxy - kube-vip/kube-vip mcr.microsoft.com: - devcontainers/base - devcontainers/go docker.io: - flannel/flannel - flannel/flannel-cni-plugin - calico/kube-controllers - serialt/rocky - serialt/alma - calico/cni - calico/pod2daemon-flexvol - calico/kube-controllers - calico/node - rancher/mirrored-flannelcni-flannel-cni-plugin - rancher/mirrored-flannelcni-flanne ","date":"2023-11-08","objectID":"/posts/skopeo/:3:2","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"3、生成动态同步的 yaml 文件 sync-image -c config.yaml ","date":"2023-11-08","objectID":"/posts/skopeo/:3:3","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"4、同步镜像 依赖的环境变量 DEST_HUB_USERNAME DEST_HUB_PASSWORD MY_GITHUB_TOKEN 同步的shell脚本 hub=\"docker.io\" repo=\"$hub/${DEST_HUB_USERNAME}\" hub2=\"registry.cn-hangzhou.aliyuncs.com\" repo2=\"$hub2/${DEST_HUB_USERNAME}\" if [ -f sync.yaml ]; then echo \"[Start] sync.......\" sudo skopeo login -u ${DEST_HUB_USERNAME} -p ${DEST_HUB_PASSWORD} ${hub} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml ${repo} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker custom_sync.yaml ${repo} sleep 3 sudo skopeo login -u ${DEST_HUB_USERNAME} -p ${DEST_HUB_PASSWORD} ${hub2} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker sync.yaml ${repo2} \\ \u0026\u0026 sudo skopeo --insecure-policy sync -a --src yaml --dest docker custom_sync.yaml ${repo2} echo \"[End] done.\" else echo \"[Error]not found sync.yaml!\" fi ","date":"2023-11-08","objectID":"/posts/skopeo/:3:4","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["同步oci镜像"],"content":"5、github action 配置文件 name: sync on: push: branches: - master - main schedule: - cron: \"0 2 * * *\" # Allows you to run this workflow manually from the Actions tab workflow_dispatch: jobs: sync: runs-on: ubuntu-latest steps: - uses: actions/checkout@v4 - name: Set up Go uses: actions/setup-go@v4 with: go-version: '\u003e=1.21.0' - name: Install dependencies run: | export version=v1.10.0 \u0026\u0026 export arch=amd64 \u0026\u0026 sudo wget https://github.com/lework/skopeo-binary/releases/download/${version}/skopeo-linux-${arch} -O /usr/bin/skopeo \u0026\u0026 sudo chmod +x /usr/bin/skopeo skopeo --version go install github.com/serialt/sync-image@latest - name: generate_sync_yaml env: SRC_HUB_USERNAME: ${{ secrets.SRC_HUB_USERNAME }} DEST_HUB_USERNAME: ${{ secrets.DEST_HUB_USERNAME }} DEST_HUB_PASSWORD: ${{ secrets.DEST_HUB_PASSWORD }} MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }} timeout-minutes: 10 run: | sync-image - name: sync image env: SRC_HUB_USERNAME: ${{ secrets.SRC_HUB_USERNAME }} DEST_HUB_USERNAME: ${{ secrets.DEST_HUB_USERNAME }} DEST_HUB_PASSWORD: ${{ secrets.DEST_HUB_PASSWORD }} run: | bash sync.sh ","date":"2023-11-08","objectID":"/posts/skopeo/:3:5","tags":["skopeo","image","oci-image-sync"],"title":"Skopeo","uri":"/posts/skopeo/"},{"categories":["morse编码"],"content":"Morse Code 二叉树记忆法 start E T I A N M S U R W D K G O H V F L P J B X C Y Z Q . - E T .. .- -. -- I A N M ... ..- .-. ..- -.. -.- --. --- S U R W D K G O .... ...- ..-. .-.. .--. .--- -... -..- -.-. -.-- --.. --.- H v F L P J B X C Y Z Q ","date":"2023-11-08","objectID":"/posts/morse-code/:1:0","tags":["morse","morse-code"],"title":"Morse Code","uri":"/posts/morse-code/"},{"categories":["系统或软件换源"],"content":"操作系统或者软件换源加速 ","date":"2023-11-07","objectID":"/posts/mirror-cn/:0:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"1、操作系统 ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"rocky # 8 base sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/rocky|g' \\ -i.bak /etc/yum.repos.d/Rocky*.repo # 8 epel sed -e 's|^metalink=|#metalink=|g' \\ -e 's|^#baseurl=https\\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -e 's|^#baseurl=https\\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -i.bak /etc/yum.repos.d/epel*.repo # 9 base sed -e 's|^mirrorlist=|#mirrorlist=|g' \\ -e 's|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.ustc.edu.cn/rocky|g' \\ -i.bak /etc/yum.repos.d/rocky*.repo # 9 epel sed -e 's|^metalink=|#metalink=|g' \\ -e 's|^#baseurl=https\\?://download.fedoraproject.org/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -e 's|^#baseurl=https\\?://download.example/pub/epel/|baseurl=https://mirrors.ustc.edu.cn/epel/|g' \\ -i.bak /etc/yum.repos.d/epel*.repo ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:1","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"ubuntu # http sed -e \"s@http://.*archive.ubuntu.com@http://mirrors.aliyun.com@g\" \\ -e \"s@http://.*security.ubuntu.com@http://mirrors.aliyun.com@g\" \\ -i.bak -i /etc/apt/sources.list # https sed -e \"s@http://.*archive.ubuntu.com@https://mirrors.aliyun.com@g\" \\ -e \"s@http://.*security.ubuntu.com@https://mirrors.aliyun.com@g\" \\ -i.bak -i /etc/apt/sources.list ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:2","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"debian # debian 12及以上 sed -i 's/\\w*.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list.d/debian.sources sed -i \"s@http://mirrors.ustc.edu.cn@https://mirrors.ustc.edu.cn@g\" /etc/apt/sources.list.d/debian.sources # debian 12以下 sed -i 's/\\w*.debian.org/mirrors.ustc.edu.cn/g' /etc/apt/sources.list sed -i \"s@http://mirrors.ustc.edu.cn@https://mirrors.ustc.edu.cn@g\" /etc/apt/sources.list ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:3","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"alpine # alpine 官方源 https://dl-cdn.alpinelinux.org/alpine/v3.18/main https://dl-cdn.alpinelinux.org/alpine/v3.18/community # ustc sed -i 's/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g' /etc/apk/repositories # edge 源 echo \"https://mirrors.ustc.edu.cn/alpine/edge/main\" \u003e\u003e /etc/apk/repositories echo \"https://mirrors.ustc.edu.cn/alpine/edge/community\" \u003e\u003e /etc/apk/repositories echo \"https://mirrors.ustc.edu.cn/alpine/edge/testing\" \u003e\u003e /etc/apk/repositories ","date":"2023-11-07","objectID":"/posts/mirror-cn/:1:4","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"2、开发语言类 go export GOPROXY=https://goproxy.cn,direct # aliyun export GOPROXY=https://mirrors.aliyun.com/goproxy/ python export PIP_MIRROR=mirrors.aliyun.com echo -e \"[global]\\nindex-url=https://${PIP_MIRROR}/pypi/simple\\n[install]\\ntrusted-host=${PIP_MIRROR}\" \u003e /etc/pip.conf # 命令配置 pip3 install xxx -i https://mirrors.aliyun.com/pypi/simple/ npm # 设置全局 npm config set registry https://registry.npmmirror.com # cmd npm install -y --registry=https://registry.npmmirror.com # 官方地址 https://registry.npmjs.org/ # 阿里云地址 https://registry.npmmirror.com # 腾讯 http://mirrors.cloud.tencent.com/npm/ # 华为 https://repo.huaweicloud.com/repository/npm/ # 南京大学 https://repo.nju.edu.cn/repository/npm/ ","date":"2023-11-07","objectID":"/posts/mirror-cn/:2:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["系统或软件换源"],"content":"3、容器代理 配置模版 { \"insecure-registries\": [ \"repo.local.com\" ], \"exec-opts\": [ \"native.cgroupdriver=systemd\" ], \"registry-mirrors\": [ \"https://docker.mirrors.sjtug.sjtu.edu.cn\", \"https://docker.nju.edu.cn\", \"http://hub-mirror.c.163.com\" ], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\", \"max-file\": \"3\" }, \"bip\":\"192.161.20.1/24\", \"dns\": [ \"119.29.29.29\", \"223.5.5.5\" ], \"data-root\": \"/var/lib/docker\", \"features\": { \"buildkit\": true } } docker registry # 上海交大 https://docker.mirrors.sjtug.sjtu.edu.cn # 南京大学 https://docker.nju.edu.cn # dockerproxy https://dockerproxy.com gcr.io # 上海交大 https://gcr-io.mirrors.sjtug.sjtu.edu.cn # 南京大学 https://gcr.nju.edu.cn # dockerproxy https://gcr.dockerproxy.com ghcr.io # 南京大学 https://htghcr.nju.edu.cn # dockerproxy https://ghcr.dockerproxy.com nvcr.io # 南京大学 https://nvcr.nju.edu.cn quay.io # 南京大学 https://quay.nju.edu.cn # dockerproxy quay.dockerproxy.com registry.k8s.io # 南京大学 k8s.mirror.nju.edu.cn # dockerproxy k8s.dockerproxy.com Microsoft Artifact Registry mcr.dockerproxy.com ","date":"2023-11-07","objectID":"/posts/mirror-cn/:3:0","tags":["mirror","source","mirror-to-cn"],"title":"To-mirror","uri":"/posts/mirror-cn/"},{"categories":["Go req 库文档"],"content":"req Go语言人性化HTTP请求库 特性 轻量级 简单 容易操作JSON和XML 容易调试和日志记录 容易上传和下载文件 容易管理Cookie 容易设置代理 容易设置超时 容易自定义HTTP客户端 安装 go get github.com/serialt/req 概要 req 基于标准库 net/http 实现了一个友好的API. Req 和 Resp 是两个最重要的结构体, 你可以把 Req 看作客户端， 把Resp 看作存放请求及其响应的容器，它们都提供许多简洁方便的API，让你可以很轻松做很多很多事情。 func (r *Req) Post(url string, v ...interface{}) (*Resp, error) 大多情况下，发起请求只有url是必选参数，其它都可选，比如请求头、请求参数、文件或请求体等。 包中含一个默认的 Req 对象, 它所有的公有方法都被req包对应的公有方法包装了，所以大多数情况下，你直接可以把req包看作一个Req对象来使用。 // 创建Req对象来发起请求 r := req.New() r.Get(url) // 直接使用req包发起请求 req.Get(url) 你可以使用 req.New() 方法来创建 *Req 作为一个单独的客户端 例子 基础用法 设置请求头 设置请求参数 设置请求体 调试 输出格式 ToJSON \u0026 ToXML 获取 *http.Response 上传 下载 Cookie 设置超时 设置代理 自定义 http.Client ","date":"2023-10-09","objectID":"/posts/req/:0:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"基础用法 header := req.Header{ \"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW46YWRtaW4=\", } param := req.Param{ \"name\": \"imroc\", \"cmd\": \"add\", } // 只有url必选，其它参数都是可选 r, err = req.Post(\"http://foo.bar/api\", header, param) if err != nil { log.Fatal(err) } r.ToJSON(\u0026foo) // 响应体转成对象 log.Printf(\"%+v\", r) // 打印详细信息 ","date":"2023-10-09","objectID":"/posts/req/:1:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求头 使用 req.Header (它实际上是一个 map[string]string) authHeader := req.Header{ \"Accept\": \"application/json\", \"Authorization\": \"Basic YWRtaW46YWRtaW4=\", } req.Get(\"https://www.baidu.com\", authHeader, req.Header{\"User-Agent\": \"V1.1\"}) 使用 http.Header header := make(http.Header) header.Set(\"Accept\", \"application/json\") req.Get(\"https://www.baidu.com\", header) 你可以使用 struct 来设置请求头，用 HeaderFromStruct 这个函数来解析你的 struct type HeaderStruct struct { UserAgent string `json:\"User-Agent\"` Authorization string `json:\"Authorization\"` } func main(){ h := HeaderStruct{ \"V1.0.0\", \"roc\", } authHeader := req.HeaderFromStruct(h) req.Get(\"https://www.baidu.com\", authHeader, req.Header{\"User-Agent\": \"V1.1\"}) } 注：请给你的 struct 加上 json tag. ","date":"2023-10-09","objectID":"/posts/req/:2:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求参数 Use req.Param (它实际上是一个 map[string]interface{}) param := req.Param{ \"id\": \"imroc\", \"pwd\": \"roc\", } req.Get(\"http://foo.bar/api\", param) // http://foo.bar/api?id=imroc\u0026pwd=roc req.Post(url, param) // 请求体 =\u003e id=imroc\u0026pwd=roc 使用 req.QueryParam 强制将请求参数拼在url后面 (它实际上也是一个 map[string]interface{}) req.Post(\"http://foo.bar/api\", req.Param{\"name\": \"roc\", \"age\": \"22\"}, req.QueryParam{\"access_token\": \"fedledGF9Hg9ehTU\"}) /* POST /api?access_token=fedledGF9Hg9ehTU HTTP/1.1 Host: foo.bar User-Agent: Go-http-client/1.1 Content-Length: 15 Content-Type: application/x-www-form-urlencoded;charset=UTF-8 Accept-Encoding: gzip age=22\u0026name=roc */ ","date":"2023-10-09","objectID":"/posts/req/:3:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置请求体 Put string, []byte and io.Reader as body directly. req.Post(url, \"id=roc\u0026cmd=query\") 将对象作为JSON或XML请求体（自动添加 Content-Type 请求头） req.Post(url, req.BodyJSON(\u0026foo)) req.Post(url, req.BodyXML(\u0026bar)) ","date":"2023-10-09","objectID":"/posts/req/:4:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"调试 将全局变量 req.Debug 设置为true，将会把所有请求的详细信息打印在标准输出。 req.Debug = true req.Post(\"http://localhost/test\" \"hi\") ","date":"2023-10-09","objectID":"/posts/req/:5:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"输出格式 您可以使用指定类型的输出格式在日志文件中记录请求和响应的信息。例如，在开发阶段使用％+v格式，可以让你观察请求和响应的细节信息。 在生产阶段使用％v或％-v输出格式，只记录所需要的信息。 ","date":"2023-10-09","objectID":"/posts/req/:6:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%+v 或 %+s 详细输出 r, _ := req.Post(url, header, param) log.Printf(\"%+v\", r) // 输出格式和Debug开启时的格式一样 ","date":"2023-10-09","objectID":"/posts/req/:6:1","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%v 或 %s 简单输出（默认格式） r, _ := req.Get(url, param) log.Printf(\"%v\\n\", r) // GET http://foo.bar/api?name=roc\u0026cmd=add {\"code\":\"0\",\"msg\":\"success\"} log.Prinln(r) // 和上面一样 ","date":"2023-10-09","objectID":"/posts/req/:6:2","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"%-v 或 %-s 简单输出并保持所有内容在一行内（请求体或响应体可能包含多行，这种格式会将所有换行、回车替换成\" \", 这在会让你在查日志的时候非常有用） ","date":"2023-10-09","objectID":"/posts/req/:6:3","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"Flag 你可以调用 SetFlags 控制输出内容，决定哪些部分能够被输出。 const ( LreqHead = 1 \u003c\u003c iota // 输出请求首部（包含请求行和请求头） LreqBody // 输出请求体 LrespHead // 输出响应首部（包含响应行和响应头） LrespBody // 输出响应体 Lcost // 输出请求所消耗掉时长 LstdFlags = LreqHead | LreqBody | LrespHead | LrespBody ) req.SetFlags(req.LreqHead | req.LreqBody | req.LrespHead) ","date":"2023-10-09","objectID":"/posts/req/:6:4","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"监控请求耗时 req.SetFlags(req.LstdFlags | req.Lcost) // 输出格式显示请求耗时 r,_ := req.Get(url) log.Println(r) // http://foo.bar/api 3.260802ms {\"code\":0 \"msg\":\"success\"} if r.Cost() \u003e 3 * time.Second { // 检查耗时 log.Println(\"WARN: slow request:\", r) } ","date":"2023-10-09","objectID":"/posts/req/:6:5","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"ToJSON \u0026 ToXML r, _ := req.Get(url) r.ToJSON(\u0026foo) r, _ = req.Post(url, req.BodyXML(\u0026bar)) r.ToXML(\u0026baz) ","date":"2023-10-09","objectID":"/posts/req/:7:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"获取 *http.Response // func (r *Req) Response() *http.Response r, _ := req.Get(url) resp := r.Response() fmt.Println(resp.StatusCode) ","date":"2023-10-09","objectID":"/posts/req/:8:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"上传 使用 req.File 匹配文件 req.Post(url, req.File(\"imroc.png\"), req.File(\"/Users/roc/Pictures/*.png\")) 使用 req.FileUpload 细粒度控制上传 file, _ := os.Open(\"imroc.png\") req.Post(url, req.FileUpload{ File: file, FieldName: \"file\", // FieldName 是表单字段名 FileName: \"avatar.png\", // Filename 是要上传的文件的名称，我们使用它来猜测mimetype，并将其上传到服务器上 }) 使用req.UploadProgress监听上传进度 progress := func(current, total int64) { fmt.Println(float32(current)/float32(total)*100, \"%\") } req.Post(url, req.File(\"/Users/roc/Pictures/*.png\"), req.UploadProgress(progress)) fmt.Println(\"upload complete\") ","date":"2023-10-09","objectID":"/posts/req/:9:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"下载 r, _ := req.Get(url) r.ToFile(\"imroc.png\") 使用req.DownloadProgress监听下载进度 progress := func(current, total int64) { fmt.Println(float32(current)/float32(total)*100, \"%\") } r, _ := req.Get(url, req.DownloadProgress(progress)) r.ToFile(\"hello.mp4\") fmt.Println(\"download complete\") ","date":"2023-10-09","objectID":"/posts/req/:10:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"Cookie 默认情况下，底层的 *http.Client 会自动管理你的cookie（如果服务器给你发了cookie，之后的请求它会自动带上cookie请求头给服务器）, 你可以调用这个方法取消自动管理： req.EnableCookie(false) 你还可以在发送请求的时候自己传入 *http.Cookie cookie := new(http.Cookie) // ...... req.Get(url, cookie) ","date":"2023-10-09","objectID":"/posts/req/:11:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置超时 req.SetTimeout(50 * time.Second) ","date":"2023-10-09","objectID":"/posts/req/:12:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"设置代理 默认情况下，如果系统环境变量有 http_proxy 或 https_proxy ，req会讲对应的地址作为对应协议的代理，你也可以自定义设置代理，或者将其置为nil，即取消代理。 req.SetProxy(func(r *http.Request) (*url.URL, error) { if strings.Contains(r.URL.Hostname(), \"google\") { return url.Parse(\"http://my.vpn.com:23456\") } return nil, nil }) 设置简单代理（将所有请求都转发到指定代理url地址上） req.SetProxyUrl(\"http://my.proxy.com:23456\") ","date":"2023-10-09","objectID":"/posts/req/:13:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go req 库文档"],"content":"自定义HTTP客户端 使用 SetClient 改变底层的 *http.Client req.SetClient(client) 给某个请求制定特定的 *http.Client client := \u0026http.Client{Timeout: 30 * time.Second} req.Get(url, client) 改变底层 *http.Client 的某些属性 req.Client().Jar, _ = cookiejar.New(nil) trans, _ := req.Client().Transport.(*http.Transport) trans.MaxIdleConns = 20 trans.TLSHandshakeTimeout = 20 * time.Second trans.DisableKeepAlives = true trans.TLSClientConfig = \u0026tls.Config{InsecureSkipVerify: true} ","date":"2023-10-09","objectID":"/posts/req/:14:0","tags":["Go","http","req"],"title":"Go Http Client","uri":"/posts/req/"},{"categories":["Go 库文档"],"content":"Go 原生http库 Go语言内置的net/http包十分的优秀，提供了HTTP客户端和服务端的实现。 ","date":"2023-10-09","objectID":"/posts/go-http/:0:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"一、net/http介绍 Go语言内置的net/http包提供了HTTP客户端和服务端的实现。 HTTP协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 ","date":"2023-10-09","objectID":"/posts/go-http/:1:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"二、HTTP客户端 Get、Head、Post和PostForm函数发出HTTP/HTTPS请求。 resp, err := http.Get(\"http://example.com/\") ... resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) ... resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) 程序在使用完response后必须关闭回复的主体。 resp, err := http.Get(\"http://example.com/\") if err != nil { // handle error } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) // ... ","date":"2023-10-09","objectID":"/posts/go-http/:2:0","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"GET请求示例 package main import ( \"fmt\" \"io\" \"net/http\" ) func main() { resp, err := http.Get(\"https://httpbin.org/uuid\") if err != nil { fmt.Printf(\"get failed, err:%v\\n\", err) return } defer resp.Body.Close() body, err := io.ReadAll(resp.Body) if err != nil { fmt.Printf(\"read from resp.Body failed, err:%v\\n\", err) return } fmt.Print(string(body)) } 自定义请求 package main import ( \"encoding/json\" \"fmt\" \"io\" \"net/http\" \"net/url\" ) type UUID struct { Uuid string `json:\"uuid\"` } func main() { apiURL := \"https://httpbin.org/uuid\" query := url.Values{} query.Add(\"q\", \"golang\") query.Add(\"page\", \"1\") ApiURL, _ := url.ParseRequestURI(apiURL) ApiURL.RawQuery = query.Encode() req, _ := http.NewRequest(\"GET\", ApiURL.String(), nil) req.Header.Add(\"Accept\", \"*/*\") client := \u0026http.Client{} resp, err := client.Do(req) if err != nil { return } defer resp.Body.Close() var uuid UUID body, err := io.ReadAll(resp.Body) if err != nil { fmt.Printf(\"read from resp.Body failed, err:%v\\n\", err) return } json.Unmarshal(body, \u0026uuid) fmt.Println(uuid.Uuid) } ","date":"2023-10-09","objectID":"/posts/go-http/:2:1","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Go 库文档"],"content":"POST 请求示例 package main import ( \"encoding/json\" \"io\" \"net/http\" \"net/url\" ) type dockerToken struct { Token string `json:\"token\"` } func main() { apiUrl := \"https://hub.docker.com/v2/users/login\" data := url.Values{} data.Set(\"username\", \"username\") data.Set(\"password\", \"password\") resp, err := http.PostForm(apiUrl, data) if err != nil { return } defer resp.Body.Close() _data, _ := io.ReadAll(resp.Body) var tmpT dockerToken json.Unmarshal(_data, \u0026tmpT) } package main import ( \"bytes\" \"io\" \"net/http\" \"net/url\" \"strings\" \"log/slog\" ) func POST1() { apiURL := \"https://httpbin.org/post\" form := url.Values{} form.Add(\"ln\", \"ln222\") form.Add(\"ip\", \"1.1.1.1\") form.Add(\"ua\", \"ua123\") client := \u0026http.Client{} req, _ := http.NewRequest(\"POST\", apiURL, strings.NewReader(form.Encode())) req.Header.Set(\"User-Agent\", \"test\") req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\") // 发送请求 resp, err := client.Do(req) if err != nil { slog.Error(\"POST request failed\", \"err\", err) return } defer resp.Body.Close() // 读取内容 body, err := io.ReadAll(resp.Body) if err != nil { slog.Error(\"POST request\", \"err\", err) } else { slog.Info(string(body)) } } func POSTJson() { apiURL := \"https://httpbin.org/post\" var jsonStr = []byte(`{\"title\":\"this is a title\", \"cate\": 1}`) client := \u0026http.Client{} req, _ := http.NewRequest(\"POST\", apiURL, bytes.NewBuffer(jsonStr)) req.Header.Set(\"User-Agent\", \"test\") req.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\") // 发送请求 resp, err := client.Do(req) if err != nil { slog.Error(\"POST request failed\", \"err\", err) return } defer resp.Body.Close() // 读取内容 body, err := io.ReadAll(resp.Body) if err != nil { slog.Error(\"POST request\", \"err\", err) } else { slog.Info(string(body)) } } func main() { // POST1() POSTJson() } ","date":"2023-10-09","objectID":"/posts/go-http/:2:2","tags":["Go","http"],"title":"Go Http","uri":"/posts/go-http/"},{"categories":["Kubernetes"],"content":"Dev in kubernetes ​ 传统的开发模式中，是代码存放在本地，使用 IDE 进行编辑和 debug 。但随着容器化火了之后，很多单一服务都进行了拆分，微服务化。在开发阶段，需要本地同时启动多个服务，这使得本地开发调试变得越来越困难。Okteto 是一个通过在 Kubernetes 中来开发和测试代码的应用程序开发工具。可以通过 Okteto 在 Kubernetes 中一键为我们启动一个开发环境，非常简单方便。Google 推出的 Skaffold 只是把 CICD 集成到本地，使用起来也比较困难。Okteto 的工作原理是在 kubernetes 中启动一个服务，把本地代码同步到 pod 中，然后执行命令让服务运行起来，Okteto 可以进行端口的转发，转发pod里服务的端口到本地，在进行 debug 的时候，pod里启动的端口可以被 kubernetes 内的其他服务所访问，本地转发的端口可以被本地的工具（例如 postman ）访问。 okteto官网文档：https://www.okteto.com/docs Go 配置文档：https://www.okteto.com/docs/samples/golang/ 示例环境： vscode 1.82.1(需要安装 Remote - Kubernetes 插件，插件code：okteto.remote-kubernetes) k3d mac ","date":"2023-09-26","objectID":"/posts/okteto/:0:0","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"安装与配置 下载okteto：https://github.com/okteto/okteto/releases [crab@Sugar ~]🐳 wget https://ghproxy.com/https://github.com/okteto/okteto/releases/download/2.20.0/okteto-Darwin-arm64 [crab@Sugar ~]🐳 chmod +x okteto-Darwin-arm64 [crab@Sugar ~]🐳 sudo mv okteto-Darwin-arm64 /usr/local/bin/okteto ","date":"2023-09-26","objectID":"/posts/okteto/:1:0","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"下载示例代码 [crab@Sugar ~]🐳 git clone https://github.com/okteto/go-getting-started go-okteto [crab@Sugar ~]🐳 cd go-okteto ","date":"2023-09-26","objectID":"/posts/okteto/:1:1","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"配置port-forward端口 需要转发两个，一个是服务的端口，另一个是debug使用的端口 okteto.yaml build: hello-world: image: serialt/go-hello-world:1.0.0 context: . deploy: - kubectl apply -f k8s.yml dev: hello-world: # 被替换的服务名 image: okteto/golang:1 command: bash sync: - .:/usr/src/app volumes: - /go - /root/.cache securityContext: capabilities: add: - SYS_PTRACE forward: - 2345:2345 - 8080:8080 # \u003c---- 增加8080服务端口转发 设置okteto context，okteto 默认会优先使用KUBECONFIG环境变量的配置文件，如果没有设置，则使用 ~/.kube/config文件 [crab@Sugar go-okteto]🐳 okteto context ✓ Context 'k3d-mycluster' selected ✓ Using dev @ k3d-mycluster ","date":"2023-09-26","objectID":"/posts/okteto/:1:2","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"启动服务 [crab@Sugar go-okteto]🐳 okteto up i Using dev @ k3d-mycluster as context i 'go-getting-started' was already deployed. To redeploy run 'okteto deploy' or 'okteto up --deploy' i Images were already built. To rebuild your images run 'okteto build' or 'okteto deploy --build' ✓ Images successfully pulled ✓ Files synchronized Context: k3d-mycluster Namespace: dev Name: hello-world Forward: 2345 -\u003e 2345 8080 -\u003e 8080 Welcome to your development container. Happy coding! dev:hello-world app\u003e dev:hello-world app\u003e ls Dockerfile LICENSE Makefile README.md bashrc go.mod k8s.yml main.go okteto.yml ","date":"2023-09-26","objectID":"/posts/okteto/:1:3","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"远程开发 # okteto终端 dev:hello-world app\u003e go run main.go Starting hello-world server... # 终端测试 [crab@Sugar ~]🐳 curl 127.0.0.1:8080 Hello world! ","date":"2023-09-26","objectID":"/posts/okteto/:1:4","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["Kubernetes"],"content":"远程调试 # okteto终端, 执行dlv命令 dev:hello-world app\u003e dlv debug --headless --listen=:2345 --log --api-version=2 API server listening at: [::]:2345 2023-09-26T13:40:51Z warning layer=rpc Listening for remote connections (connections are not authenticated nor encrypted) 2023-09-26T13:40:51Z info layer=debugger launching process with args: [./__debug_bin3213431902] 2023-09-26T13:40:51Z debug layer=debugger Adding target 575 \"/usr/src/app/__debug_bin3213431902\" # main.go 打上debug标记 func helloServer(w http.ResponseWriter, r *http.Request) { fmt.Fprint(w, \"Hello world from Okteto!, k3d is great! \") fmt.Println(\"okteto ccccccc\") # 标记此行 } 在vscode debug中点击开始debug 使用命令请求 http://127.0.0.1:8080，即可debug到标记点 [sugar@Sugar go-okteto]🐳 curl http://127.0.0.1:8080 Hello world from Okteto!, k3d is great! ","date":"2023-09-26","objectID":"/posts/okteto/:1:5","tags":["okteto","kubernetes","vscode","dev"],"title":"Okteto","uri":"/posts/okteto/"},{"categories":["vscode"],"content":"Debug shell 1、安装插件 安装bashdb插件 rogalmic.bash-debug 2、增加一个vscode launch.json配置文件 Select Debug -\u003e Add Configuration to add custom debug configuration 示例： { \"configurations\": [ { \"type\": \"bashdb\", \"request\": \"launch\", \"name\": \"Bash-Debug\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${workspaceFolder}/ccc.sh\", \"args\": [] }, ] } 就可以像debug其他语言一样进行调试shell脚本 ","date":"2023-09-24","objectID":"/posts/debug-shell-in-vscode/:0:0","tags":["shell"],"title":"Debug Shell in VSCode","uri":"/posts/debug-shell-in-vscode/"},{"categories":["mirror-web"],"content":"清华镜像网页搭建镜像站 tuna mirror-web地址：https://github.com/tuna/mirror-web.git tuna mirror-web基于jekyll开发，由于ruby环境安装复杂，因此采用docker编译，但在build镜像的时候，出现安装包依赖安装失败，在多次测试后，无法build成镜像。前段时间，在查看mirror-web段issues时，有人询问mirror-web段README.md文档的下一步，官方给了一点提示，有关于基于nginx的第三方模块来实现目录第渲染的提示说明，再次尝试后，经历各种困难和折磨，终于摸索出。 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:0","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"1、下载mirror-web的jekyll编译环境 tuna的编译镜像：tunathu/mirror-web 在下载tunathu/mirror-web时发生了一个小问题，由于在国内使用的docker镜像加速，下载的镜像是旧版本的，但境外的服务器下载的镜像是最新的，在踩坑后果断推到自己的dockerhub上，新的下载地址：serialt/tuna-mirror-web。 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:1","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"2、下载github仓库 git clone https://github.com/tuna/mirror-web.git /opt/mirror-web ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:2","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"3、下载额外资源和编译 cd /opt/mirror-web wget https://mirrors.tuna.tsinghua.edu.cn/static/tunasync.json -O static/tunasync.json wget https://mirrors.tuna.tsinghua.edu.cn/static/tunet.json -O static/tunet.json mkdir -p static/status wget https://mirrors.tuna.tsinghua.edu.cn/static/status/isoinfo.json -O static/status/isoinfo.json docker run -it -v /opt/mirror-web/:/data serialt/tuna-mirror-web:20211006 编译的后静态文件在_site里 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:3","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"4、编译nginx 需要安装第三方模块 modules/ngx_http_js_module.so modules/ngx_http_fancyindex_module.so [root@serialt nginx]# ll 总用量 1068 drwxr-xr-x 9 sonar sonar 186 10月 5 22:27 nginx-1.20.1 -rw-r--r-- 1 root root 1061461 5月 25 23:34 nginx-1.20.1.tar.gz drwxrwxr-x 3 root root 217 10月 27 2020 ngx-fancyindex-0.5.1 -rw-r--r-- 1 root root 25148 10月 27 2020 ngx-fancyindex-0.5.1.tar.xz drwxr-xr-x 10 root root 228 10月 6 15:49 njs # njs下载 git clone https://github.com/nginx/njs # ngx-fancyindex 下载 wget https://github.com/aperezdc/ngx-fancyindex/releases/download/v0.5.1/ngx-fancyindex-0.5.1.tar.xz 编译： [root@serialt nginx]# ls nginx-1.20.1 nginx-1.20.1.tar.gz ngx-fancyindex-0.5.1 ngx-fancyindex-0.5.1.tar.xz njs [root@serialt nginx]# cd nginx-1.20.1/ [root@serialt nginx-1.20.1]# ./configure --prefix=/usr/local/nginx --with-pcre --with-http_auth_request_module --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-mail --with-mail_ssl_module --with-stream --with-stream_ssl_module --with-stream_realip_module --add-dynamic-module=/root/nginx/ngx-fancyindex-0.5.1 --add-dynamic-module=/root/nginx/njs/nginx # add m 3997 [2022-02-25 00:49:21] [root] [10.5.0.10] ./configure --with-compat --add-dynamic-module=/root/github/tuna-mirror-web/njs-0.6.2/nginx 3998 [2022-02-25 00:49:31] [root] [10.5.0.10] make modules nginx配置文件内容 [root@serialt mirrors]# cat /usr/local/nginx/conf/nginx.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; load_module modules/ngx_http_js_module.so; load_module modules/ngx_http_fancyindex_module.so; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; map $http_user_agent $isbrowser { default 0; \"~*validation server\" 0; \"~*mozilla\" 1; } js_path /opt/mirror-web/_site/static/njs; js_include /opt/mirror-web/_site/static/njs/all.njs; #js_path /opt/mirror-web/static/njs; #js_include /opt/mirror-web/static/njs/all.njs; server { listen 8007; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; #root /opt/mirror-web/_site; fancyindex_header /fancy-index/before; fancyindex_footer /fancy-index/after; fancyindex_exact_size off; fancyindex_time_format \"%d %b %Y %H:%M:%S +0000\"; fancyindex_name_length 256; error_page 404 /404.html; location /fancy-index { internal; root /opt/mirror-web/_site; subrequest_output_buffer_size 100k; location = /fancy-index/before { js_content fancyIndexBeforeRender; } location = /fancy-index/after { js_content fancyIndexAfterRender; } } location / { root /opt/mirror-web/_site; index index.html index.htm; #try_files /_site/$uri $uri/ /_site/$uri; fancyindex on; } # location / { # root html; # index index.html index.htm; # } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } } } [root@serialt mirrors]# ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:4","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"5、镜像资源暴露 方法1：以软链接形式存放在/opt/mirror-web/_site中 [root@serialt _site]# pwd /opt/mirror-web/_site [root@serialt _site]# ll 总用量 160 -rw-r--r-- 1 root root 16415 10月 6 15:37 404.html drwxr-xr-x 2 root root 6 10月 6 17:14 cc drwxr-xr-x 2 root root 19 10月 6 17:14 centos drwxr-xr-x 2 root root 94 10月 6 09:25 fancy-index -rw-r--r-- 1 root root 36650 10月 6 15:37 feed.xml drwxr-xr-x 103 root root 4096 10月 6 09:25 help -rw-r--r-- 1 root root 27679 10月 6 15:37 index.html -rw-r--r-- 1 root root 20728 10月 6 15:37 legacy_index.html -rw-r--r-- 1 root root 18092 10月 6 15:37 LICENSE drwxr-xr-x 47 root root 4096 10月 6 09:25 news -rw-r--r-- 1 root root 58 10月 6 15:37 robots.txt -rw-r--r-- 1 root root 19134 10月 6 15:37 sitemap.xml drwxr-xr-x 8 root root 115 10月 6 15:37 static drwxr-xr-x 2 root root 24 10月 6 09:25 status 方法二：把/opt/mirror-web/_site里的文件以软链接的方式链接到镜像的跟目录（建议使用） ln -snf /opt/mirror-web/_site/* /opt/imau 目录描述文件：_data/options.yml 站点资源显示控制：static/tunasync.json tunasync.json [ { \"name\": \"ant\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"book\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"centos\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"dev\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"frp\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"git\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"go\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"grafana\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"iso\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"jdk\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"jmeter\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"kubernetes\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"mac\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"monitor\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"node\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"root-ca\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"other\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"printer\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"prometheus\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"pycharm\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"python\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"repo\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"script\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"test\", \"is_master\": true, \"status\": \"success\" }, { \"name\": \"tool\", \"is_master\": true, \"status\": \"success\" } ] \"last_update\": \"2022-01-11 16:39:37 +0800\", \"last_update_ts\": 1641890377, \"last_started\": \"2022-01-11 16:39:21 +0800\", \"last_started_ts\": 1641890361, \"last_ended\": \"2022-01-11 16:39:37 +0800\", \"last_ended_ts\": 1641890377, \"next_schedule\": \"2022-01-11 22:39:37 +0800\", \"next_schedule_ts\": 1641911977, \"upstream\": \"rsync://msync.centos.org/CentOS/\", - status: 'success' last_update: '-' name: \"AUR\" url: 'https://aur.tuna.tsinghua.edu.cn/' upstream: 'https://aur.archlinux.org/' is_master: true options.yml # Content Related mirror_desc: - name: git desc: git 二进制编译版本 - name: go desc: golang 开发环境 - name: grafana desc: grafana 的安装包 - name: helm desc: helm 的二进制发行包 - name: ios desc: 镜像文件，如centos, ubuntu, rocky等 - name: jdk desc: java 开发环境安装包 new_mirrors: - hugging-face-models - endeavouros - ubuntukylin - putty - postmarketOS - postmarketOS-images - obs-studio - stellarium unlisted_mirrors: - status: 'success' last_update: '-' name: \"AUR\" url: 'https://aur.tuna.tsinghua.edu.cn/' upstream: 'https://aur.archlinux.org/' is_master: true - link_to: 'osdn' name: \"manjaro-cd\" url: '/osdn/storage/g/m/ma/manjaro/' - link_to: 'osdn' name: \"manjaro-arm-cd\" url: '/osdn/storage/g/m/ma/manjaro-arm/' - link_to: 'osdn' name: \"mxlinux-isos\" url: '/osdn/storage/g/m/mx/mx-linux/ISOs/' - link_to: 'osdn' name: \"garuda-linux\" url: '/osdn/storage/g/g/ga/garuda-linux/' - link_to: 'osdn' name: \"linuxlite-cd\" url: '/osdn/storage/g/l/li/linuxlite/' - link_to: 'github-release' name: \"prometheus\" url: '/github-rele","date":"2023-09-24","objectID":"/posts/tuna-web/:1:5","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"6、docker镜像使用 静态文件编译 构建 Jekyll 的 docker 镜像环境复杂，建议直接使用官方或者已经存在的镜像tunathu/mirror-web或者serialt/tuna-mirror-web [root@tc ~]# docker run -it -v /path/to/mirror-web/:/data serialt/tuna-mirror-web 一些动态数据已经下载，若需要最新的，可以就行以下操作,然后在构建 下载最新的动态数据文件 wget https://mirrors.tuna.tsinghua.edu.cn/static/tunasync.json -O static/tunasync.json wget https://mirrors.tuna.tsinghua.edu.cn/static/tunet.json -O static/tunet.json mkdir -p static/status wget https://mirrors.tuna.tsinghua.edu.cn/static/status/isoinfo.json -O static/status/isoinfo.json 运行服务 docker镜像网页根目录: /opt/mirror-web 镜像站资源根目录: /opt/mirror 启动服务 docker run -tid -v /opt/tuna-mirror-web/_site:/opt/mirror-web -v /opt/mirror:/opt/mirror -p 8099:80 --name=tuna-mirror-nginx serialt/tuna-mirror-web-nginx:7b0c89d version: \"3\" networks: tuna-mirror-nginx: external: false services: tuna-mirror-nginx: image: serialt/tuna-mirror-web-nginx:latest container_name: mirror-nginx hostname: mirror-nginx restart: always networks: - tuna-mirror-nginx volumes: - \"/etc/localtime:/etc/localtime:ro\" - \"/opt/mirror-web/_site:/opt/mirror-web\" - \"/opt/mirror:/opt/mirror\" ports: - \"80:80\" dns: - 223.5.5.5 - 223.6.6.6 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:6","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"新镜像站版本发布 docker run -it --rm -v /opt/tuna-mirror-web:/data serialt/tuna-mirror-web docker restart tuna-mirror-nginx ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:7","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"编写说明 _data/options.yml: 是显示在镜像站主页对各个目录的说明 static/tunasync.json: 是对当前repo的同步信息的描述，可以自行编辑，也可以从tuna上下载 help: help目录里存有各个repo的帮助信息，在主页上会显示有个\"?\" news: 镜像站的新闻信息 ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:8","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["mirror-web"],"content":"help 说明 permalink 是表示help的首页的路径，必须要有 --- layout: help category: help mirrorid: app permalink: /help/app/ --- ","date":"2023-09-24","objectID":"/posts/tuna-web/:1:9","tags":["mirrors"],"title":"Tuna Web","uri":"/posts/tuna-web/"},{"categories":["Kubernetes"],"content":"helm oci ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:0","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"缘由 Helm 3.8 版本开始，支持使用oci进行存储chart。镜像存储常用的Harbor在v1.6版本开始支持Helm Chart仓库功能， chart仓库由chartmuseum以插件的方式提供。随着兼容OCI规范的Helm Chart在社区上被更广泛地接受，Helm Chart能以Artifact的形式在Harbor中存储和管理，不再依赖ChartMuseum，因此Harbor在v2.8.0版本中，移除对ChartMuseum的支持。 ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:1","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"registry 仓库使用 基本使用 ### registry # 登录 helm registry login -u serialt docker.io # 注销 helm registry logout docker.io # pull chart helm fetch oci://docker.io/serialt/loki-stack --version=2.9.11 # push chart helm push loki-stack-2.9.11.tgz oci://docker.io/serialt oci支持的其他命令 helm pull helm show helm template helm install helm upgrade $ helm pull oci://localhost:5000/helm-charts/mychart --version 0.1.0 Pulled: localhost:5000/helm-charts/mychart:0.1.0 Digest: sha256:0be7ec9fb7b962b46d81e4bb74fdcdb7089d965d3baca9f85d64948b05b402ff $ helm show all oci://localhost:5000/helm-charts/mychart --version 0.1.0 apiVersion: v2 appVersion: 1.16.0 description: A Helm chart for Kubernetes name: mychart ... $ helm template myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0 --- # Source: mychart/templates/serviceaccount.yaml apiVersion: v1 kind: ServiceAccount ... $ helm install myrelease oci://localhost:5000/helm-charts/mychart --version 0.1.0 NAME: myrelease LAST DEPLOYED: Wed Oct 27 15:11:40 2021 NAMESPACE: default STATUS: deployed REVISION: 1 NOTES: ... $ helm upgrade myrelease oci://localhost:5000/helm-charts/mychart --version 0.2.0 Release \"myrelease\" has been upgraded. Happy Helming! NAME: myrelease LAST DEPLOYED: Wed Oct 27 15:12:05 2021 NAMESPACE: default STATUS: deployed REVISION: 2 NOTES: ... ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:2","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"},{"categories":["Kubernetes"],"content":"迁移 chart repo 到 oci 仓库 基于 github action 镜像 helm repo 仓库到 docker hub，以加速 helm repo 到访问。 migrate-chart ","date":"2023-09-24","objectID":"/posts/helm-migrate-oci/:1:3","tags":["helm"],"title":"Helm Migrate OCI","uri":"/posts/helm-migrate-oci/"}]