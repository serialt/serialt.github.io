Go 代码片段



go goroutines pool

```go
package main

import (
	"fmt"

	"github.com/sourcegraph/conc/pool"
)

func main() {
	p := pool.New().WithMaxGoroutines(3)
	for i := 1; i <= 5; i++ {
		p.Go(func() {
			fmt.Println(i)
		})
	}
	p.Wait()
}

```



带ctx 的go goroutines pool

```go
package main

import (
	"context"
	"errors"
	"fmt"

	"github.com/sourcegraph/conc/pool"
)

func main() {
	p := pool.New().
		WithMaxGoroutines(4).
		WithContext(context.Background()).
		WithCancelOnError()
	for i := 0; i < 3; i++ {
		i := i
		p.Go(func(ctx context.Context) error {
			if i == 2 {
				return errors.New("I will cancel all other tasks!")
			}
			<-ctx.Done()
			return nil
		})
	}
	err := p.Wait()
	fmt.Println(err)
	// Output:
	// I will cancel all other tasks!
}

```

channel 

```go
package main

import (
	"fmt"
)

func main() {
	ch := make(chan int, 3)
	// wg := conc.NewWaitGroup()
	go func() {
		for i := 0; i < 1000; i++ {
			ch <- i
		}
		close(ch)
	}()
	// wg.Wait()

	for v := range ch {
		fmt.Println(v)
	}

}

```

```go
package main

import (
	"fmt"

	"github.com/sourcegraph/conc"
)

func main() {
	ch := make(chan int)
	// ch2 := make(chan bool)

	wg := conc.NewWaitGroup()

	wg.Go(func() {
		for i := 0; i < 100; i++ {
			ch <- i
		}
		close(ch)
	})

	for sub := range ch {
		fmt.Println(sub)
	}

}

```



复杂结构体slice排序

```go
type Person struct {
	Name string
	Age  int
	Book int
}


	people := []Person{
		{"Alice", 30, 5},
		{"Bob", 25, 2},
		{"Charlie", 30, 55},
		{"David", 25, 33},
	}
	// 使用 sort.Slice 进行排序，按年龄升序排列,年龄相同则按book排序
	sort.Slice(people, func(i, j int) bool {
		if people[i].Age == people[j].Age {
			return people[i].Book < people[j].Book
		}
		return people[i].Age < people[j].Age
	})

```

errorgroup

```go
package main

import (
	"errors"
	"fmt"

	"golang.org/x/sync/errgroup"
)

func main() {
	eg := errgroup.Group{}
	eg.Go(func() error {
		fmt.Println("go1")
		return nil
	})
	eg.Go(func() error {
		fmt.Println("go2")
		err := errors.New("go2 err")
		return err
	})
	err := eg.Wait()
	if err != nil {
		fmt.Println("err =", err)
	}
}

// 带ctx
func main1() {
	eg, ctx := errgroup.WithContext(context.Background())
	eg.Go(func() error {
		time.Sleep(1 * time.Second)
		select {
		case <-ctx.Done():
			fmt.Println("go1 cancel, err = ", ctx.Err())
		default:
			fmt.Println("go1 run")
		}
		return nil
	})
	eg.Go(func() error {
		err := errors.New("go2 err")
		return err
	})
	err := eg.Wait()
	if err != nil {
		fmt.Println("err =", err)
	}
}

// 限制并发数
func main2() {
	eg := errgroup.Group{}
	eg.SetLimit(2)
	eg.TryGo(func() error {
		fmt.Println("go1 run")
		return nil
	})
	eg.TryGo(func() error {
		err := errors.New("go2 err")
		return err
	})
	eg.TryGo(func() error {
		fmt.Println("go3 run")
		return nil
	})
	err := eg.Wait()
	if err != nil {
		fmt.Println("err =", err)
	}
}

```

gorm clause

```go
	err = pa.WithContext(ctx).Clauses(
		clause.OnConflict{
			Columns: []clause.Column{
				{Name: user.Code.ColumnName().String()},
			},
			TargetWhere: clause.Where{
				Exprs: []clause.Expression{
					clause.Expr{
						SQL: "deleted_at = 0",
					},
				},
			},
			DoUpdates: clause.AssignmentColumns(cols),
		},
	).
		CreateInBatches(items, 30)


// 表设计优化，这样只有当deleted_at为null的时候，才会触发code的唯一性校验
// create unique index pa_code
//    on pa (code) where deleted_at is null;

```

recover 使用

```go
func main3() {
	defer func() {
		if err2 := recover(); err2 != nil {
			fmt.Printf("Run panic error: %v", err2)
		}
	}()
	fmt.Println("xxx")
}

```

func 作为传参

```go
package main

import "fmt"

func apply(x int, y int, f func(int, int) int) int {
	return f(x, y)
}

func sum(a int, b int) int {
	return a + b
}

func main() {

	asum := apply(5, 10, sum)
	fmt.Println(asum)
}


//
func sayHello(name string) func() string {
	return func() string {
		return "Hello, " + name
	}
}
func main2() {
	hello := sayHello("Go")
	fmt.Println(hello()) // 输出: Hello, Go
}
```

单元测试

```go
package main

import (
	"testing"
)

func TestInit(t *testing.T) {
	t.Log("heh")

	helper := PersonHelper{}
	helper.init("pleuvoir")
	t.Log(helper.Name)
}

```

函数运行时间

```go
func TimeSince(f func()) string {
  start := time.Now() // 获取当前时间
  f()                 // 执行传入的函数
  // 获取结束的时间
  elapsed := time.Since(start)
  str := fmt.Sprintf("该函数执行完成耗时：%v", elapsed)
  return str
}

func main() {
  result := TimeSince(timeTest)
  fmt.Println(result)
}

func timeTest() {
  // 运行的函数
  sum := 0
  for i := 0; i < 1111111111; i++ {
    sum++
  }
}
```

随机数

```
//start 10，end 20，将获得这之间的随机数
func RandomSum(start int, end int) int {
  // 以当前时间戳作为种子，确保每次生成的随机数都不同
  rand.Seed(time.Now().Unix())
  // 生成一个指定范围之间的随机整数

  randomInt := rand.Intn(end-start+1) + start
  return randomInt
}

```

生成随机字符串

```
const (
  letterBytes  = "abcdefghijklmnopqrstuvwxyz"
  capitalBytes = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  numberBytes  = "0123456789"
  symbolBytes  = "!@#$%^&*()"
)

func RandStringBytes(n int, randomString string) string {
  rand.Seed(time.Now().Unix())
  b := make([]byte, n)
  for i := range b {
    b[i] = randomString[rand.Intn(len(randomString))]
  }
  return string(b)
}

func main() {
//传入随机字符串的长度，以及需要随机那些字符串
  randomString := RandStringBytes(10, letterBytes+numberBytes)
  fmt.Println(randomString)
}
```

url 解析

```
func main() {
  // 要解析的 URL 字符串
  urlString := "https://www.example.com/path/to/resource?key1=value1&key2=value2#fragment"

  // 解析 URL 字符串
  parsedUrl, err := url.Parse(urlString)
  if err != nil {
    panic(err)
  }

  // 输出解析后的 URL 的各个部分
  fmt.Println("Scheme:", parsedUrl.Scheme)
  fmt.Println("Host:", parsedUrl.Host)
  fmt.Println("Path:", parsedUrl.Path)
  fmt.Println("RawQuery:", parsedUrl.RawQuery)
  fmt.Println("Fragment:", parsedUrl.Fragment)

  // 解析 URL 的查询参数
  query := parsedUrl.Query()
  fmt.Println("key1:", query.Get("key1"))
  fmt.Println("key2:", query.Get("key2"))
}
```

执行系统命令

```
func main() {
  //cmd := exec.Command("calc.exe")
  cmd := exec.Command("ls", "-la")
  output, err := cmd.Output()
  if err != nil {
    fmt.Println(err)
    return
  }
  fmt.Println(string(output))
}
```

web 文件服务

```
func main() {
  http.Handle("/", http.FileServer(http.Dir(".")))
  http.ListenAndServe(":8082", nil)
}
```



